---
title: "osa-fiscal-health-index"
author: "Alexander Nielson"
date: "2/27/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Program Description

**Purpose**

**Input(s)**

```{r}
dsn_aws        <- "transpAWS"
dsn_salesforce <- "salesforce"
```

**Output(s)**

# Get Input
```{r}
validation_type <- 
#  "file_analysis"
 "batch_analysis"

if(validation_type=="batch_analysis") {
  entity_id <- 1010
}

if (validation_type == "file_analysis"){
  downloaded_file <- "location_of_pipe_delim_file.txt"
}
```


# Libraries and Data Sources

```{r}
options(scipen=6)

library(lubridate)
library(magrittr)
library(odbc)
library(readxl) 
library(tidyverse)
library(stringi) 
library(tidyr)
library(plotly)

odbc_aws <- dbConnect(odbc::odbc(), dsn_aws)
odbc_sf  <- dbConnect(odbc::odbc(), dsn_salesforce)

rm(dsn_aws, dsn_salesforce)
```

# Function Definitions

## agg_dollars_and_records
```{r}
agg_dollars_and_records<- function(df, ...){
  # Purpose: groups the data by supplied grouping variables, and aggregates the
  # date to have a total dollar amount and a count for the number of transactions
  # with such variables. Basically this will group uca codings into dollar and
  # frequency amounts. Two metrics of interest to Alex.
  #
  # Inputs: *df (tibble or dataframe): a dataframe which has the grouping variables. it should have an amount column
  #         *... : the grouping variables. should be a uca field.
  # Outputs: tibble :an aggregated tibble
  
  grouping_vars <- enquos(...)
  
  agg_table <- df %>% 
    group_by(!!! grouping_vars) %>% 
    summarize(total_amount = sum(amount),
              num_of_trans = n()) %>% 
    arrange(desc(fiscal_year, total_amount))
  
}
```
## validate_nrow

```{r}
validate_nrow <- function(df, expected_nrow) {
  # Verify the number of rows in a data frame rounds to the expected value.
  #
  # Arguments:
  #   df (tbl): The data frame to validate.
  #   expected_nrow (num): The number of rows the report should contain, rounded
  #     to one significant digit.
  #
  # Value:
  #   Nothing, or a `stop()` message.
  
  if (!identical(df%>%nrow()%>%signif(1),
                 expected_nrow)) {
    
    paste0("The rounded number of rows in ", 
           deparse(substitute(df)),
           " is not near the expected ", 
           expected_nrow, 
           ". Did the data frame import correctly? 
           Did the number of entities we monitor change significantly?") %>% 
      stop()
  }
}
```

## make_current_begin_fy

```{r}
make_current_begin_fy <- function(begin_fy_unchecked) {
  # Update an outdated fiscal year begin date.
  #
  # Arguments:
  #   begin_fy_unchecked (Date): The first day of the entity's fiscal year, not
  #     yet verified to reflect the current fiscal year.
  #
  # Value:
  #   Date.
  #
  # Comments:
  #   As of 2019-03, our instance of Salesforce does not reliably update the
  #   Fiscal_Year_Begins__c field. Coding the update in this program was a
  #   quicker solution than waiting for the problem to be fixed in Salesforce.
  
  !(begin_fy_unchecked > today()) || 
    
    stop("make_current_begin_fy() must not be applied to future dates.",
         call. = FALSE)
  
  fy_interval <- 
    begin_fy_unchecked %--% ((begin_fy_unchecked + years(1)) - 1)
  
  if (today() %within% fy_interval) {
    
    begin_fy_unchecked
    
  } else {
    
    year_correction <- 
      (year(today()) - year(begin_fy_unchecked)) %>% 
      if_else(
        month(begin_fy_unchecked) != 1 &
          month(begin_fy_unchecked) > month(today()),
        . - 1,
        .)
    
    begin_fy_unchecked + months(12 * year_correction)
  }
}
```

## query_batch_ids

```{r}
query_batch_ids <- function(t_id) {
  # Query an entity's processed and processing batch IDs.
  #
  # Arguments:
  #   t_id (num): The entity's Transparency ID, as queried from Salesforce
  #     rather than Transparency.
  #
  # Value:
  #   Numeric.
  #
  # Comments:
  #   The 'DONTDELETE' batch status is a variation of 'PROCESSED.' DONTDELETE 
  #   indicates the data in the batch has been split among multiple transaction
  #   tables, as the batch contains data from a fiscal year that has been 
  #   archived.
  
  if (is.na(t_id)) {
    
    return(vector(mode = "numeric", length = 0)) 
  }
  
  dbGetQuery(
    odbc_aws,
    paste("
          SELECT id
          FROM batch
          WHERE entity_id = ", t_id, "
          AND status IN ('PROCESSED', 'PROCESSING', 'DONTDELETE')")) %>% 
    .[["id"]] %>%
    as.numeric()
}
```


# Load Lookup Table

```{r}
osa_lookup_file_name <- "osa_lookup.xlsx"

osa_lookup <- excel_sheets(osa_lookup_file_name) %>%
  map(read_excel, path = osa_lookup_file_name)

names(osa_lookup) <- c("fund", "funct", "account")

rm(osa_lookup_file_name)

```

browse the lookup tables
```{r,eval = FALSE}
osa_lookup
```

#Load Salesforce Data

```{r}
sf_entity_info <- 
  dbGetQuery(
    odbc_sf,
    "SELECT 
      a.Name                          AS name,
      a.Id                            AS id,
      a.Transparency_ID__c            AS t_id,
      a.Fiscal_Year_Begins__c         AS begin_fy,
      a.Expense_Revenue_Start_Date__c AS begin_report_er, 
      a.Wage_Start_Date__c            AS begin_report_w2,
      r.Name AS govt_type
    FROM Account         AS a
    LEFT JOIN RecordType AS r
      ON a.RecordTypeId = r.Id
    WHERE a.RecordTypeId IN (
      SELECT Id
      FROM RecordType
      WHERE SobjectType = 'Account'
      AND IsActive = 'TRUE'
      AND Name NOT IN (
        'Community User',
        'Component', -- This govt type contains local governments, but not ones for which we enforce compliance.
        'Court (Search Under Parent Entity)',
        'CPA Firm',
        'Educational Foundation or Component Unit', -- Not an entity we review for compliance.
        'Financial Institution',
        'Health Provider',
        'Non Profits'))
    AND a.Name NOT IN (
      'Intermountain Power Agency',
      'test city 2',
      'Utah Associated Municipal Power Systems',
      'Utah Municipal Power Agency')
    AND Entity_Status__c NOT IN ('Inactive', 'Dissolved')
    AND (
      a.Expense_Revenue_Start_Date__c <= DATE() OR
      a.Expense_Revenue_Start_Date__c IS NULL)") %>% 
  as_tibble() %>% 
  mutate(
  govt_type = 
    if_else(
      name %in% 
        c("State of Utah",
          "Utah System of Higher Education - Student Loan Guarantee Program",
          "Utah System of Higher Education - Student Loan Purchase Program",
          "Utah System of Higher Education - Utah Educational Savings Plan dba my529",
          "Utah System of Higher Education - Utah State Board of Regents"),
      "Monitored State Agency",
      govt_type)) %>% 
  filter(govt_type != "State of Utah (agencies/depts/comp units/ etc.)") %>% 
  # The State of Utah is required to report to Transparent Utah, but in most instances we do not monitor its data:
  filter(name != "State of Utah") #%>% 
  #select(-govt_type)

sf_exemptions <- 
  dbGetQuery(
    odbc_sf,
    paste("
          SELECT 
            a.Name                          AS name,
            t.Account__c                    AS id,
            a.Fiscal_Year_Begins__c         AS begin_fy,
            t.Transparency_type_exempted__c AS transaction_type,
            t.Recurring_Exemption__c        AS recurring_exemption,
            t.Exemption_Start_Date__c       AS exemption_start,
            t.Exemption_End_Date__c         AS exemption_end,
            t.Permanent_or_Temporary__c     AS exemption_type,
            t.Exemption_Reason__c           AS reason
          FROM (
            SELECT 
              Account__c,
              Exemption_Start_Date__c,
              Exemption_End_Date__c,
              Recurring_Exemption__c,
              Transparency_type_exempted__c,
              Permanent_or_Temporary__c,
              Exemption_Reason__c
            FROM Transparency_Exemption__c
            WHERE IsDeleted = FALSE) t
          LEFT JOIN Account a
          ON t.Account__c = a.Id
          WHERE a.Entity_Status__c IN (
            'Current', 
            'On hold', 
            'Delinquent', 
            'Suspended')
          AND a.Name != 'test city 2'")) %>% 
  as_tibble()

```

# Validate the salesforce data
```{r}
validate_nrow(sf_entity_info, 1000)

# Validate sf_entity_info ####

if (class(sf_entity_info$name)            != "character" ||
    class(sf_entity_info$id)              != "character" ||
    class(sf_entity_info$t_id)            != "numeric"   ||
    class(sf_entity_info$begin_fy)        != "Date"      ||
    class(sf_entity_info$begin_report_er) != "Date"      ||
    class(sf_entity_info$begin_report_w2) != "Date") {

  stop("One or more fields in sf_entity_info is not of the correct class.
       Review the data before continuing.",
       call. = FALSE)  
}

if (sf_entity_info %>% 
    filter(is.na(name) | is.na(id)) %>% 
    nrow() > 0) {

  name_or_id_is_na <- 
    sf_entity_info %>% 
    filter(is.na(name) | is.na(id))
  
  stop("Entities should have a name and Salesforce ID.
       A missing name or Salesforce ID indicates some larger problem with the 
       data. Review and correct before continuing.",
       call. = FALSE)
}

if (sf_entity_info %>% 
    filter(is.na(begin_fy)) %>% 
    nrow() > 0) {
  
  missing_begin_fy <- 
    sf_entity_info %>% 
    filter(is.na(begin_fy))
  
  stop("begin_fy should be populated for every active government. Update 
       Salesforce and reimport before continuing.", call. = FALSE)
    }

if (sf_entity_info %>% 
    filter(
      !is.na(t_id) & (
        is.na(begin_report_er) |
        is.na(begin_report_w2))) %>% 
    nrow() > 0) {
  
  incomplete_info <- 
    sf_entity_info %>% 
    filter(
      !is.na(t_id) & (
        is.na(begin_report_er) |
        is.na(begin_report_w2)))
  
  stop("Entities with a Transparency ID must also have non-NA values for 
       begin_report_er and begin_report_w2 in
       order to determine their compliance status.",
       call. = FALSE)
}

if (sf_entity_info %>% 
    filter(begin_fy > today()) %>%
    nrow() > 0) {
  
  future_begin_fy <- 
    sf_entity_info %>% 
    filter(begin_fy > today())
  
  stop("Entities must not have a begin_fy value in the future.
       Correct and reimport before continuing.",
       call. = FALSE)
}

if (sf_entity_info %>% 
    filter(begin_fy <= (today() - months(12))) %>% 
    nrow() > 0) {
  
  sf_entity_info$begin_fy <- 
    sf_entity_info$begin_fy %>% 
    map_dbl(make_current_begin_fy)
  
  class(sf_entity_info$begin_fy) <- "Date"
}

if (sf_entity_info %>% 
    filter(month(begin_report_er) != month(begin_fy)) %>% 
    nrow() > 0) {
  
  begin_report_er_month_is_wrong <- 
    sf_entity_info %>% 
    filter(month(begin_report_er) != month(begin_fy))
  
  stop("The month of begin_report_er must match the month of begin_fy.
       Update in Salesforce (create an exemption if necessary) and reimport.",
       call. = FALSE)
}

if (sf_entity_info %>% 
    filter(month(begin_report_w2) != month(begin_fy)) %>% 
    nrow() > 0) {
  
  begin_report_w2_month_is_wrong <- 
    sf_entity_info %>% 
    filter(month(begin_report_w2) != month(begin_fy))
  
  stop("The month of begin_report_w2 must match the month of begin_fy.
       Update in Salesforce (create an exemption if necessary) and reimport.",
       call. = FALSE)
}

if (sf_entity_info %>% 
    filter(begin_report_w2 < begin_report_er) %>% 
    nrow() > 0) {
  
  w2_date_prior_to_exp_rev <- 
    sf_entity_info %>% 
    filter(begin_report_w2 < begin_report_er)
  
  stop("begin_report_w2 should not be earlier than
       begin_report_er. Update in Salesforce and reimport.", 
       call. = FALSE)
}
```



# Now lets query the batches for the first few entities

## Get a subset of entities
```{r}
report <- sf_entity_info %>% 
  filter(govt_type == "City") %>% 
  mutate(batches = map(t_id ,query_batch_ids))
```


```{r}
#report$batches

```

```{r}
query_transactions <- function(batches_list, lookup_table) {
  #wrangled the batches to be readable in MySQL.
  # I know this is more work, and
  # that the batches could have been checked in sql, but I want my report to be
  # able to show exactly which batches were examined. I want this the repor
  # visible at the R level and not some additional thing happens on the SQL
  # backend.
  batches_wrangled <- batches_list %>%
    unlist() %>%
    as.character() %>%
    str_split(" ") %>%
    unlist() %>%
    #sQuote() %>%
    paste(collapse = ", ")
  
  
  # 1. Query the database, get all the records -----------------------------------
  
  transaction_report <-
    dbGetQuery(
      odbc_aws,
      paste(
        "
      SELECT id,
      batch_id,
      amount,
      fiscal_year,
      account_number,
      type
      FROM transaction
      WHERE batch_id IN (",
      batches_wrangled,
      ")"
      )
    ) %>%
    as_tibble()
  
  # 2. check for NA or "" ------------------------------------------------------
  
  # generates a invalid table we can send the entity.
  invalid_reported_na <- transaction_report %>%
    filter(account_number == "",
           is.na(account_number))
  
  # filter out the bad uca
  transaction_report <- transaction_report %>%
    filter(account_number != "",
           !is.na(account_number))
  
  # 3. check correct length ----------------------------------------------------
  
  # 19 is for normal, 25 is for USBE (dashes are included in string legth)
  invalid_length <- transaction_report %>%
    filter(nchar(account_number) != 19) %>%
    mutate(
      account_number_length = nchar(account_number),
      reason = case_when(
        account_number_length < 19 ~ paste("uca code block too short - length =", account_number_length),
        account_number_length > 19 ~ paste("uca code block too long - length =", account_number_length)
      )
    )
  
  transaction_report <- transaction_report %>%
    filter(nchar(account_number) == 19)
  
  # 4. check for valid form. ie: ##-###-####-####-###-#### ---------------------
  
  invalid_form <-
    transaction_report %>%
    filter(!str_detect(
      .$account_number,
      regex("^[:digit:]{3}-[:digit:]{6}-[:digit:]{8}$")
    ))
  
  transaction_report <-
    transaction_report %>%
    filter(str_detect(
      .$account_number,
      regex("^[:digit:]{3}-[:digit:]{6}-[:digit:]{8}$")
    ))
  
  #5. enrich the transaction_report --------------------------------------------
  
  transaction_report <- transaction_report %>%
    mutate(
      fund                    = .[["account_number"]] %>% substr(0, 3),
      funct                   = .[["account_number"]] %>% substr(5, 10),
      account                 = .[["account_number"]] %>%  substr(12, 19),
      fund_code_primary       = str_sub(fund, 0, 2),
      fund_code_secondary     = str_sub(fund, 2, 3),
      funct_code_primary      = str_sub(funct, 0, 2),
      funct_code_secondary    = str_sub(funct, 3, 4),
      funct_code_tertiary     = str_sub(funct, 5, 6),
      account_code_primary    = str_sub(account, 0, 2),
      account_code_secondary  = str_sub(account, 3, 4),
      account_code_tertiary   = str_sub(account, 5, 6),
      account_code_quaternary = str_sub(account, 7, 8)
    ) %>%
    
    # Now we need to join ucoa.xlsx, so we know what the codes mean.
    
    # join the funds
    left_join(
      lookup_table %>%
        pluck("fund") %>%
        as_tibble() %>%
        select(
          number,
          fund_description = description,
          #lu_fund_code_primary = code_primary,
          #lu_fund_code_secondary = code_secondary,
          fund_level_primary = level_primary,
          fund_level_secondary = level_secondary
        ),
      by = c("fund" = "number")
    ) %>%
    # join the functions
    left_join(
      lookup_table %>%
        pluck("funct") %>%
        as_tibble() %>%
        select(
          number,
          funct_description = description,
          #lu_funct_code_primary = code_primary,
          #lu_funct_code_secondary = code_secondary,
          #lu_funct_code_tertiary = code_tertiary,
          funct_level_primary = level_primary,
          funct_level_secondary = level_secondary,
          funct_level_tertiary = level_tertiary
        ),
      by = c("funct" = "number")
    ) %>%
    # join the accounts
    left_join(
      lookup_table %>%
        pluck("account") %>%
        as_tibble() %>%
        select(
          number,
          account_description = description,
          #lu_account_code_primary = code_primary,
          #lu_account_code_secondary = code_secondary,
          #lu_account_code_tertiary = code_tertiary,
          account_level_primary = level_primary,
          account_level_secondary = level_secondary,
          account_level_tertiary = level_tertiary
        ),
      by = c("account" = "number")
    )
  
  #6. FFind unmapped uca codes
  
  #find wrong fund code
  unmapped_fund_code <- transaction_report %>%
    filter(!fund %in% (lookup_table %>%
                         pluck("fund")  %>%
                         select(number) %>%
                         unlist())) %>%
    select(
      id,
      batch_id,
      amount,
      fiscal_year,
      account_number,
      fund,
      fund_code_primary,
      fund_code_secondary
    )
  
  #If the fund code does not map, we want to know which component of the code
  #failed. ie: was it the primary or secondary component?
  
  # check primary
  unmapped_fund_code_primary <- unmapped_fund_code %>%
    filter(!fund_code_primary %in% (
      lookup_table %>%
        pluck("fund")  %>%
        select(code_primary) %>%
        unlist()
    ))
  
  #check secondary
  unmapped_fund_code_primary <- unmapped_fund_code %>%
    filter(!fund_code_primary %in% (
      lookup_table %>%
        pluck("fund")  %>%
        select(code_primary) %>%
        unlist()
    ))
  
  
  #find wrong function code
  unmapped_funct_code <- transaction_report %>%
    filter(!funct %in% (
      lookup_table %>%
        pluck("funct") %>%
        select(number) %>%
        unlist()
    )) %>%
    select(
      id,
      batch_id,
      amount,
      fiscal_year,
      account_number,
      funct,
      funct_code_primary,
      funct_code_secondary,
      funct_code_tertiary
    )
  
  #If the funct code does not map, we want to know which component of the code
  #failed. ie: was it the primary, secondary, or tertiary component?
  
  #check funct primary
  unmapped_funct_code_primary <- unmapped_funct_code %>%
    filter(!funct_code_primary %in% (
      lookup_table %>%
        pluck("funct")  %>%
        select(code_primary) %>%
        unlist()
    ))
  
  #check funct secondary
  unmapped_funct_code_secondary <- unmapped_funct_code %>%
    filter(
      funct_code_primary %in% (
        lookup_table %>%
          pluck("funct")  %>%
          select(code_primary) %>%
          unlist()
      )
      ,
      !funct_code_secondary %in% (
        lookup_table %>%
          pluck("funct")  %>%
          select(code_secondary) %>%
          unlist()
      )
    )
  
  
  # check funct tertiary
  unmapped_funct_code_tertiary <- unmapped_funct_code %>%
    filter(
      funct_code_primary %in% (
        lookup_table %>%
          pluck("funct")  %>%
          select(code_primary) %>%
          unlist()
      )
      ,
      funct_code_secondary %in% (
        lookup_table %>%
          pluck("funct")  %>%
          select(code_secondary) %>%
          unlist()
      )
      ,
      !funct_code_tertiary %in% (
        lookup_table %>%
          pluck("funct")  %>%
          select(code_tertiary) %>%
          unlist()
      )
    )
  
  # check account
  unmapped_account_code <- transaction_report %>%
    filter(!account %in% (
      lookup_table %>%
        pluck("account") %>%
        select(number)   %>%
        unlist()
    )) %>%
    select(
      id,
      batch_id,
      amount,
      fiscal_year,
      account_number,
      account,
      account_code_primary,
      account_code_secondary,
      account_code_tertiary,
      account_code_quaternary
    )
  
  #If the funct code does not map, we want to know which component of the code
  #failed. ie: was it the primary, secondary, tertiary, quaternary component?
  
  #check account primary
  unmapped_account_code_primary <- unmapped_account_code %>%
    filter(!account_code_primary %in% (
      lookup_table %>%
        pluck("account")  %>%
        select(code_primary) %>%
        unlist()
    ))
  #check account secondary
  unmapped_account_code_secondary <- unmapped_account_code %>%
    filter(
      account_code_primary %in% (
        lookup_table %>%
          pluck("account")  %>%
          select(code_primary) %>%
          unlist()
      ),
      !account_code_secondary %in% (
        lookup_table %>%
          pluck("account")  %>%
          select(code_secondary) %>%
          unlist()
      )
    )
  
  unmapped_account_code_tertiary <- unmapped_account_code %>%
    filter(
      account_code_primary %in% (
        lookup_table %>%
          pluck("account")  %>%
          select(code_primary) %>%
          unlist()
      ),
      account_code_secondary %in% (
        lookup_table %>%
          pluck("account")  %>%
          select(code_secondary) %>%
          unlist()
      ),
      !account_code_tertiary %in% (
        lookup_table %>%
          pluck("account")  %>%
          select(code_tertiary) %>%
          unlist()
      )
    )
  
  unmapped_account_code_quaternary <- unmapped_account_code %>%
    filter(
      account_code_primary %in% (
        lookup_table %>%
          pluck("account")  %>%
          select(code_primary) %>%
          unlist()
      ),
      account_code_secondary %in% (
        lookup_table %>%
          pluck("account")  %>%
          select(code_secondary) %>%
          unlist()
      ),
      account_code_tertiary %in% (
        lookup_table %>%
          pluck("account")  %>%
          select(code_tertiary) %>%
          unlist()
      )#,
      # !account_code_quaternary %in% (
      #   lookup_table %>%
      #     pluck("account")  %>%
      #     select(code_quaternary) %>%
      #     unlist()
      # )
    )
  
  
  #now remove incorrectly mapped. we will save them to report, but do not want
  #them in our analysis.
  transaction_report <- transaction_report %>%
    anti_join(unmapped_fund_code, by = "id") %>%
    anti_join(unmapped_funct_code, by = "id") %>%
    anti_join(unmapped_account_code, by = "id")
  
  
  # consolidate ----------------------------------------------------------------
  entity_info <-
    list(
      "transaction_report" = transaction_report,                            #1
      "invalid_reported_na" = invalid_reported_na,                          #2  
      "invalid_length" = invalid_length,                                    #3 
      "invalid_form" = invalid_form,                                        #4
      "unmapped_fund_code" = unmapped_fund_code,                            #5 
      "unmapped_funct_code" = unmapped_funct_code,                          #6 
      "unmapped_funct_code_primary" = unmapped_funct_code_primary,          #7
      "unmapped_funct_code_secondary" = unmapped_funct_code_secondary,      #8
      "unmapped_funct_code_tertiary" = unmapped_funct_code_tertiary,        #9
      "unmapped_account_code" = unmapped_account_code,                      #10
      "unmapped_account_code_primary" = unmapped_account_code_primary,      #11
      "unmapped_account_code_secondary" = unmapped_account_code_secondary,  #12
      "unmapped_account_code_tertiary" = unmapped_account_code_tertiary,    #13
      "unmapped_account_code_quaternary" = unmapped_account_code_quaternary #14
    ) #%>% enframe()
}

```

Single batch examples -- show tae
```{r, eval = FALSE}

#vignettes of atomized uca
temp<- query_transactions(54158, osa_lookup) # contains incorrect length, form, and unmapped account code, it also shows how it can find the quaternary failure
temp<- query_transactions(54230,osa_lookup) # contains incorrect funct, and secondary funct code. 
temp<- query_transactions(53818,osa_lookup) # contains incorrect account, and primary account code. 
```


```{r,eval=FALSE}
temp
```

# validate entity uca
```{r}
# takes about 10 minutes
report <- report %>% 
  mutate(queried_transactions = batches %>% map(query_transactions, osa_lookup))
```

```{r}
#report
```


```{r}
#view a single entities transaction reports.
#report %>% slice(1) %>% pull(queried_transactions) %>% pluck(1) %>% pluck("transaction_report")
```

```{r}
#report %>% slice(1) %>% pull(queried_transactions) %>% pluck(1) %>% pluck("invalid_length")
```

# ===================
# =Fiscal Health Analysis=
# ===================
#Boilerplates
##generate some interesting aggregations for an entity
### boilerplate for agg by account
```{r, eval = FALSE}
entity_by_year <- report %>%
  slice(1) %>%
  pull(queried_transactions) %>%
  pluck(1) %>%
  pluck("transaction_report") %>%
  agg_dollars_and_records(account_description, account, fiscal_year)


```
### boilerplate for agg by funct
```{r, eval = FALSE}
entity_by_year <- report %>%
  slice(2) %>%
  pull(queried_transactions) %>%
  pluck(1) %>%
  pluck("transaction_report") %>%
  agg_dollars_and_records(funct_description, funct, fiscal_year)

```

# Single Entity Comparison

## compare_rev_exp
```{r}
compare_rev_exp<- function(df, ...){
  # Purpose: groups the data by supplied grouping variables, and aggregates the
  # date to have a total dollar amount and a count for the number of transactions
  # with such variables. Basically this will group uca codings into dollar and
  # frequency amounts. Two metrics of interest to Alex.
  #
  # Inputs: *df (tibble or dataframe): a dataframe which has the grouping variables. it should have an amount column
  #         *... : the grouping variables. should be a uca field.
  # Outputs: tibble :an aggregated tibble
  
  grouping_vars <- enquos(...)
  
  revenues <- df %>%
    filter(type == 2) %>%
    group_by(!!!grouping_vars) %>%
    summarize(rev_total_amount = sum(amount),
              rev_num_of_trans = n()) %>%
    mutate(rev_total_amount = rev_total_amount) 
  
  expenditures <- df %>%
    filter(type == 1) %>%
    group_by(!!!grouping_vars) %>%
    summarize(exp_total_amount = sum(amount),
              exp_num_of_trans = n()) %>%
    mutate(exp_total_amount = exp_total_amount)
    
  
  difference <- revenues %>% full_join(expenditures,) %>%
    mutate_each(~ replace(., which(is.na(.)), 0))
  
  difference <- difference %>%
    mutate(
      rev_minus_exp = abs(rev_total_amount) - abs(exp_total_amount),
      avg = mean(rev_minus_exp),
      sd = sd(rev_minus_exp),
      sd = case_when(is.na(sd) ~ 0,
                     TRUE ~ sd)
    ) %>%
    mutate(sord_category = case_when(
      rev_minus_exp >= 0 ~ "surplus",
                                rev_minus_exp <  0 ~ "deficit"),
           
           avg_category = case_when (
             rev_minus_exp > avg + sd ~ "above average",
             rev_minus_exp < avg - sd ~ "below average",
             TRUE ~ "average"
           )
           ) %>%
    mutate(fiscal_year = factor(as.character(fiscal_year))) %>% 
    arrange(desc(fiscal_year, exp_total_amount))
}
```
## Fund Analysis

### plot_fund_by_year
```{r}

plot_fund_by_year <- function(fiscal_years,entity_name, df) {
  fiscal_years <- enquo(fiscal_years)
  df <- df %>% filter(fiscal_year == !!fiscal_years)
  
  ggplot(data = df,
         aes(x = fund_descr_code,
             y = rev_minus_exp,
             fill = sord_category)) +
    geom_bar(stat = "identity") +
    coord_flip() +
    geom_text(
      aes(label = paste(
        "$", format(rev_minus_exp, big.mark = ",", trim = TRUE)
      )),
      color = "black",
      fontface = "bold",
      #vjust = 'inward',
      hjust = "inward",
      size = 4,
      alpha = .5
    ) +
    labs(
      title = paste("Fund- Fiscal Health Analysis - Fiscal Year: ", as_label(fiscal_years)),
      subtitle = paste(entity_name)
    ) +
    scale_fill_manual(
      values = c(
        "surplus" = "#7CAE00",
        "deficit" = "#F8766D"
      )
    ) +
        xlab("Fiscal Year") +
      ylab("Difference of Revenues and Expenditures")
  
}
```

## Funct Analysis



### plot_funct_by_year
```{r}


plot_funct_by_year <- function(fiscal_years, entity_name, df) {
  fiscal_years <- enquo(fiscal_years)
  df <- df %>% filter(fiscal_year == !!fiscal_years)
  
  ggplot(data = df,
         aes(x = funct_descr_code,
             y = rev_minus_exp,
             fill = sord_category)) +
    geom_bar(stat = "identity") +
    coord_flip() +
    geom_text(
      aes(label = paste(
        "$", format(rev_minus_exp, big.mark = ",", trim = TRUE)
      )),
      color = "black",
      fontface = "bold",
      #vjust = 'inward',
      hjust = "inward",
      size = 4,
      alpha = .5
    ) +
    labs(
      title = paste(
        "Function- Fiscal Health Analysis - Fiscal Year: ",
        as_label(fiscal_years)
      ),
      subtitle = paste(entity_name)
    ) +
    scale_fill_manual(values = c("surplus" = "#7CAE00",
                                 "deficit" = "#F8766D")) +
    xlab("Fiscal Year") +
    ylab("Difference of Revenues and Expenditures")
  
}
```

### plot_net_amount_by_funct
```{r}
plot_net_amount_by_funct <-
  function(funct_numbers, entity_name, df) {
    funct_numbers <- enquo(funct_numbers)
    
    df <- df %>% filter(funct == !!funct_numbers)
    
    ggplot(data = df,
           aes(x = fiscal_year,
               y = rev_minus_exp,
               fill = avg_category)) +
      geom_bar(stat = "identity") +
      coord_flip() +
      geom_text(
        aes(label = paste(
          "$", format(rev_minus_exp, big.mark = ",", trim = TRUE)
        )),
        color = "black",
        fontface = "bold",
        #vjust = 'inward',
        hjust = "inward",
        size = 4,
        alpha = .5
      ) +
      labs(
        title = paste(
          "Funct-",
          # case_when(
          #   str_detect(account_numbers, "^0") ~ "Not Applicable",
          #   str_detect(account_numbers, "^0") ~ "General Government",
          #   str_detect(account_numbers, "^0") ~ "Not Applicable",
          #   str_detect(account_numbers, "^0") ~ "Not Applicable",
          # ),
          df$funct_description
        ),
        subtitle = paste(entity_name)
      ) +
      
      scale_fill_manual(
        values = c(
          
          "average" = "#00BFC4",
          "below average" = "#F8766D",
          "above average" = "#7CAE00"
          # #"average" = "#00BFC4",
          # "deficit" = "#F8766D",
          # "surplus" = "#7CAE00"
        )
      ) +
      ylab("Fiscal Year") +
      xlab("Net Amount ($)")
    
  }

```


##Account Analysis

#### agg_accounts
```{r}
agg_accounts <- function(df,trxn_type, ...) {
  # Purpose: groups the data by supplied grouping variables, and aggregates the
  # date to have a total dollar amount and a count for the number of transactions
  # with such variables. Basically this will group uca codings into dollar and
  # frequency amounts. Two metrics of interest to Alex.
  #
  # Inputs: *df (tibble or dataframe): a dataframe which has the grouping variables. it should have an amount column
  #         * trxn_type (a numeric): 1 == expense, 2==revenue, 3 == w2. meant to stand for Revenue OR Expense.
  #         *... : the grouping variables. should be a uca field.
  # Outputs: tibble :an aggregated tibble
  
  grouping_vars <- enquos(...)
  
  expenditures <- df %>%
    filter(type == trxn_type) %>%
    group_by(!!!grouping_vars) %>%
    summarize(total_amount = sum(amount),
              num_of_trans = n()) %>%
    mutate(avg = mean(total_amount),
           stdv = sd(total_amount)) %>%
    arrange(desc(fiscal_year, total_amount)) %>%
    mutate(
      fiscal_year = factor(fiscal_year),
      category = case_when(
        total_amount <= avg - stdv ~ 'below average',
        total_amount >= avg + stdv ~ 'above average',
        TRUE ~ 'average'
      )
    )
  
}
```






### plot_account_by_year
```{r}
plot_account_by_year <- function(fiscal_years,entity_name, df) {
  fiscal_years <- enquo(fiscal_years)
  df <- df %>% filter(fiscal_year == !!fiscal_years)
  
  ggplot(data = df,
         aes(x = account_description,
             y = total_amount,
             fill = category)) +
    geom_bar(stat = "identity") +
    coord_flip() +
    geom_text(
      aes(label = paste(
        "$", format(total_amount, big.mark = ",", trim = TRUE)
      )),
      color = "black",
      fontface = "bold",
      #vjust = 'inward',
      hjust = "inward",
      size = 4,
      alpha = .5
    ) +
    labs(
      title = paste("Account - Fiscal Year: ", as_label(fiscal_years)),
      subtitle = paste(entity_name)
    ) +
    scale_fill_manual(
      values = c(
        "average" = "#00BFC4",
        "below average" = "#F8766D",
        "above average" = "#7CAE00"
      )
    ) +
          ylab("Fiscal Year") +
      xlab("Net Amount ($)")
  
}
```

### plot_net_amount_by_account
```{r}
plot_net_amount_by_account <-
  function(account_numbers, entity_name, df) {
    fiscal_years <- enquo(account_numbers)
    df <- df %>% filter(account == !!account_numbers)
    
    ggplot(data = df,
           aes(x = fiscal_year,
               y = total_amount,
               fill = category)) +
      geom_bar(stat = "identity") +
      coord_flip() +
      geom_text(
        aes(label = paste(
          "$", format(total_amount, big.mark = ",", trim = TRUE)
        )),
        color = "black",
        fontface = "bold",
        #vjust = 'inward',
        hjust = "inward",
        size = 4,
        alpha = .5
      ) +
      labs(
        title = paste(
          "Account-",
          if_else(
            str_detect(account_numbers, "^4"),
            "Expenditure:",
            "Revenue:"
          ),
          df$account_description
        ),
        subtitle = paste(entity_name)
      ) +
      
      scale_fill_manual(
        values = c(
          "average" = "#00BFC4",
          "below average" = "#F8766D",
          "above average" = "#7CAE00"
        )
      ) +
      ylab("Fiscal Year") +
      xlab("Net Amount ($)")
    
  }

```

#automate Single entity Comparison
```{r}
entity_fiscal_health_data <- function(entity_name , report_df){
  #Fund Analysis:
  agg_fund_by_fiscal_year <- report_df %>%
    filter(name == entity_name) %>%
    pull(queried_transactions) %>%
    pluck(1) %>%
    pluck("transaction_report") %>%
    filter(fiscal_year < 2020) %>%
    compare_rev_exp(fund, fund_description, fiscal_year) %>% 
    mutate(fund_descr_code = paste(fund,fund_description))
  
  fund_faceted_plot <-
    ggplot(data = agg_fund_by_fiscal_year,
           aes(x = fund_descr_code,
               y = rev_minus_exp,
               fill = sord_category)) +
    geom_bar(stat = "identity") +
    coord_flip() +
    geom_text(
      aes(label = paste(
        "$", format(rev_minus_exp, big.mark = ",", trim = TRUE)
      )),
      color = "black",
      fontface = "bold",
      #vjust = 'inward',
      hjust = "inward",
      size = 3,
      alpha = .5
    ) +
    facet_grid(fiscal_year ~ .) +
    labs(
      title = paste("Fund - Fiscal Health Analysis"),
      subtitle = paste(entity_name)#,
    )+
    xlab("Fund")+
    ylab("Difference of Revenues and Expenditures") +
    scale_fill_manual(
      values = c(
        "surplus" = "#7CAE00",
        "deficit" = "#F8766D"
      )
    )
  
  
  
  fund_years <-
    agg_fund_by_fiscal_year %>% pull(fiscal_year) %>% unique()
  
  fund_individual_plots <-
    fund_years %>% map(plot_fund_by_year,entity_name=entity_name, agg_fund_by_fiscal_year)
  
  fund_plots <- list(fund_faceted_plot = fund_faceted_plot,
                     fund_individual_plots = fund_individual_plots)
  
  fund_health <- list(data = agg_fund_by_fiscal_year,
                      plots = fund_plots)
  
  
  
  #Funct Analysis
  agg_funct_by_fiscal_year <- report_df %>%
    filter(name == entity_name) %>%
    pull(queried_transactions) %>%
    pluck(1) %>%
    pluck("transaction_report") %>%
    filter(fiscal_year < 2020) %>%
    compare_rev_exp(funct, funct_description, fiscal_year) %>% 
    mutate(funct_descr_code = paste(funct,funct_description))
  
  funct_faceted_plot <-
    ggplot(data = agg_funct_by_fiscal_year,
           aes(x = funct_descr_code,
               y = rev_minus_exp,
               fill = sord_category)) +
    geom_bar(stat = "identity") +
    coord_flip() +
    geom_text(
      aes(label = paste(
        "$", format(rev_minus_exp, big.mark = ",", trim = TRUE)
      )),
      color = "black",
      fontface = "bold",
      #vjust = 'inward',
      hjust = "inward",
      size = 3,
      alpha = .5
    ) +
    facet_grid(fiscal_year ~ .) +
    labs(
      title = paste("Function - Fiscal Health Analysis"),
      subtitle = paste(entity_name))+
    xlab("Funct")+
    ylab("Difference of Revenues and Expenditures")+
    scale_fill_manual(
      values = c(
        "surplus" = "#7CAE00",
        "deficit" = "#F8766D"
      )
    )
  

  funct_years <-
    agg_funct_by_fiscal_year %>% pull(fiscal_year) %>% unique()
  
  funct_individual_plots <-
    funct_years %>% map(plot_funct_by_year,entity_name=entity_name, agg_funct_by_fiscal_year)
  


  
  #funct by Year
  entity_by_funct_year <- report_df %>%
    filter(name == entity_name) %>%
    pull(queried_transactions) %>%
    pluck(1) %>%
    pluck("transaction_report") %>%
    filter(fiscal_year < 2020) %>%
    compare_rev_exp(funct, funct_description, fiscal_year)
  
  funct_nums <- entity_by_funct_year %>% pull(funct) %>% unique()
  
  funct_by_year_plots<- funct_nums %>% map(plot_net_amount_by_funct,
                                           entity_name=entity_name,
                                           entity_by_funct_year)
  
  funct_plots <- list(funct_faceted_plot = funct_faceted_plot,
                   funct_individual_plots = funct_individual_plots,
                   funct_by_year_plots = funct_by_year_plots)
  
  funct_health <- list(data = agg_funct_by_fiscal_year,
                       plots = funct_plots)
  
  
  # Account Analysis
  entity_by_expenditures_year <- report_df %>%
    filter(name == entity_name) %>%
    pull(queried_transactions) %>%
    pluck(1) %>%
    pluck("transaction_report") %>%
    filter(fiscal_year < 2020) %>%
    agg_accounts(trxn_type = 1, account, account_description, fiscal_year)
  
  
  entity_by_revenues_year <- report_df %>%
    filter(name == entity_name) %>%
    pull(queried_transactions) %>%
    pluck(1) %>%
    pluck("transaction_report") %>%
    filter(fiscal_year < 2020) %>%
    agg_accounts(trxn_type = 2, account, account_description, fiscal_year)
  
  ## analyze all accounts in a year by year basis
  ### expenditures
  exp_years <-
    entity_by_expenditures_year %>% pull(fiscal_year) %>% unique()
  exp_plots <-
    exp_years %>% map(plot_account_by_year,entity_name=entity_name, entity_by_expenditures_year)
  exp_plots
  ### revenues
  rev_years <-
    entity_by_revenues_year %>% pull(fiscal_year) %>% unique()
  rev_plots <-
    rev_years %>% map(plot_account_by_year,entity_name=entity_name, entity_by_revenues_year)
  rev_plots
  
  plots_all_accounts_by_year <- list(exp_plots = exp_plots,
                                     rev_plots = rev_plots)
  
  ## analyze single accounts in a year by year basis
  ### expenditures
  
  #### get all of the expenditure accounts for that entity:
  account_nums <-
    entity_by_expenditures_year %>% pull(account) %>% unique()
  exp_plots <-
    account_nums %>% map(plot_net_amount_by_account,entity_name=entity_name, entity_by_expenditures_year)
  exp_plots
  
  #### get all of the revenues accounts for that entity:
  account_nums <-
    entity_by_revenues_year %>% pull(account) %>% unique()
  rev_plots <-
    account_nums %>% map(plot_net_amount_by_account,entity_name=entity_name, entity_by_revenues_year)
  rev_plots
  
  plots_single_account_by_year <- list(exp_plots = exp_plots,
                                       rev_plots = rev_plots)
  
  account_health <- list(revenue_data = entity_by_revenues_year, 
                         expenditure_data = entity_by_expenditures_year,
                         plots_single_account_by_year = plots_single_account_by_year,
                         plots_all_accounts_by_year = plots_all_accounts_by_year)
  
  fiscal_health <- list(fund_health = fund_health,
                        funct_health = funct_health,
                        account_health = account_health)
}
```
# testing
```{r}
# report <- report %>% 
#   mutate(
#     
    name <- "Alpine City"
    fiscal_health <- name %>% map(entity_fiscal_health_data, report)

#)
```





```{r}
# temp<- fiscal_health %>% pluck(1) %>%
#   pluck("funct_health")
#   

temp<- fiscal_health %>% pluck(1) %>%
  pluck("fund_health") %>% 
  pluck("plots") 
temp
```

```{r}
temp<- fiscal_health %>% pluck(1) %>% 
  pluck("funct_health") %>% 
  pluck("plots") %>% 
  #pluck("funct_faceted_plot")
  #pluck("funct_individual_plots")
  pluck("funct_by_year_plots")
temp
# temp<- fiscal_health %>% pluck(1) %>% 
#   pluck("funct_health") %>% 
#   pluck("data") #%>% 
#   #pluck("funct_faceted_plot")
#   #pluck("funct_individual_plots")
#   pluck("funct_by_year_plots")
```


```{r}
plotly_temp <- ggplotly(temp)
```

```{r}
#names_of_entities<- report %>% pull(name)

test_report <- report %>% mutate(
  fiscal_health = name %>% map(entity_fiscal_health_data, report)
)

#fiscal_health <- names_of_entities %>%  map(entity_fiscal_health_data, report)

```

```{r}
test_report %>% filter()
```

```{r, eval = FALSE}
#get all
test_report %>% filter(t_id ==1601) %>% pluck("fiscal_health") 

#get fund
test_report %>% filter(t_id ==1601) %>% pluck("fiscal_health") %>% pluck(1) %>% pluck("fund_health") 

#get funct
test_report %>% filter(t_id ==1601) %>% pluck("fiscal_health") %>% pluck(1) %>% pluck("funct_health") 

#get account
test_report %>% filter(t_id ==1601) %>% pluck("fiscal_health") %>% pluck(1) %>% pluck("account_health") 
```
