---
title: "osa-data-quality-index"
author: "Alexander Nielson"
date: "3/4/2020"
output: html_document
---

building upon david's suggestion to create a data quality index


---
title: "osa-batch-validation"
author: "Alexander Nielson"
date: "2/25/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# 0. Program Description

**Purpose**

**Input(s)**

```{r}
dsn_aws        <- "transpAWS"
dsn_salesforce <- "salesforce"
```

**Output(s)**

# I. Libraries and DBMS

```{r}
options(scipen=6)

library(lubridate)
library(magrittr)
library(odbc)
library(openxlsx)
library(readxl) 
library(tidyverse)
library(stringi) 
library(tidyr)
library(forcats)
library(RColorBrewer)

odbc_aws <- dbConnect(odbc::odbc(), dsn_aws)
odbc_sf  <- dbConnect(odbc::odbc(), dsn_salesforce)

rm(dsn_aws, dsn_salesforce)
```

# II. Function Definitions

## a. database validation
### validate_nrow

```{r}
validate_nrow <- function(df, expected_nrow) {
  # Verify the number of rows in a data frame rounds to the expected value.
  #
  # Arguments:
  #   df (tbl): The data frame to validate.
  #   expected_nrow (num): The number of rows the report should contain, rounded
  #     to one significant digit.
  #
  # Value:
  #   Nothing, or a `stop()` message.
  
  if (!identical(df%>%nrow()%>%signif(1),
                 expected_nrow)) {
    
    paste0("The rounded number of rows in ", 
           deparse(substitute(df)),
           " is not near the expected ", 
           expected_nrow, 
           ". Did the data frame import correctly? 
           Did the number of entities we monitor change significantly?") %>% 
      stop()
  }
}
```

### make_current_begin_fy

```{r}
make_current_begin_fy <- function(begin_fy_unchecked) {
  # Update an outdated fiscal year begin date.
  #
  # Arguments:
  #   begin_fy_unchecked (Date): The first day of the entity's fiscal year, not
  #     yet verified to reflect the current fiscal year.
  #
  # Value:
  #   Date.
  #
  # Comments:
  #   As of 2019-03, our instance of Salesforce does not reliably update the
  #   Fiscal_Year_Begins__c field. Coding the update in this program was a
  #   quicker solution than waiting for the problem to be fixed in Salesforce.
  
  !(begin_fy_unchecked > today()) || 
    
    stop("make_current_begin_fy() must not be applied to future dates.",
         call. = FALSE)
  
  fy_interval <- 
    begin_fy_unchecked %--% ((begin_fy_unchecked + years(1)) - 1)
  
  if (today() %within% fy_interval) {
    
    begin_fy_unchecked
    
  } else {
    
    year_correction <- 
      (year(today()) - year(begin_fy_unchecked)) %>% 
      if_else(
        month(begin_fy_unchecked) != 1 &
          month(begin_fy_unchecked) > month(today()),
        . - 1,
        .)
    
    begin_fy_unchecked + months(12 * year_correction)
  }
}
```

### query_batch_ids

```{r}
query_batch_ids <- function(t_id) {
  # Query an entity's processed and processing batch IDs.
  #
  # Arguments:
  #   t_id (num): The entity's Transparency ID, as queried from Salesforce
  #     rather than Transparency.
  #
  # Value:
  #   Numeric.
  #
  # Comments:
  #   The 'DONTDELETE' batch status is a variation of 'PROCESSED.' DONTDELETE 
  #   indicates the data in the batch has been split among multiple transaction
  #   tables, as the batch contains data from a fiscal year that has been 
  #   archived.
  
  if (is.na(t_id)) {
    
    return(vector(mode = "numeric", length = 0)) 
  }
  
  dbGetQuery(
    odbc_aws,
    paste("
          SELECT id
          FROM batch
          WHERE entity_id = ", t_id, "
          AND status IN ('PROCESSED', 'PROCESSING', 'DONTDELETE')")) %>% 
    .[["id"]] %>%
    as.numeric()
}
```
## b. UCA related
###  query_and_validate_transactions
```{r}
query_and_validate_transactions <- function(batches_list, lookup_table) {
  # Query an entity's batches, and validate the the transactions.
  #
  # Arguments:
  #   t_id (num): The entity's Transparency ID, as queried from Salesforce
  #     rather than Transparency.
  #
  # Value:
  #   Numeric.
  #
  # Comments:
  #   The 'DONTDELETE' batch status is a variation of 'PROCESSED.' DONTDELETE 
  #   indicates the data in the batch has been split among multiple transaction
  #   tables, as the batch contains data from a fiscal year that has been 
  #   archived.
  
  
  batches_wrangled <- batches_list %>%
    unlist() %>%
    as.character() %>%
    str_split(" ") %>%
    unlist() %>%
    #sQuote() %>%
    paste(collapse = ", ")
  
  
  # 1. Query the database, get all the records -----------------------------------
  
  transaction_report <-
    dbGetQuery(
      odbc_aws,
      paste(
        "
      SELECT id,
      batch_id,
      amount,
      fiscal_year,
      account_number,
      type
      FROM transaction
      WHERE (type = 1 OR type = 2)
      AND batch_id IN (",
      batches_wrangled,
      ")"
      
      )
    ) %>%
    as_tibble()
  
  # bsafeguard against "invalid mutlibyte string, element 372860" error
  transaction_report$account_number  <- iconv(transaction_report$account_number ,"WINDOWS-1252","UTF-8")
  
  # 2. check for NA or "" ------------------------------------------------------
  
  invalid_reported_na <- transaction_report %>%
    filter(account_number == "",
           is.na(account_number))
  
  transaction_report <- transaction_report %>%
    filter(account_number != "",
           !is.na(account_number))
  
  # 3. check correct length ----------------------------------------------------
  #Note: 19 is for OSA, 25 is for USBE (dashes are included in string legth)
  invalid_length <- transaction_report %>%
    filter(stri_length(account_number) != 19) %>%
    mutate(
      account_number_length = nchar(account_number),
      reason = case_when(
        account_number_length < 19 ~ paste("Invalid Length - Code block too short - length =", account_number_length),
        account_number_length > 19 ~ paste("Invalid Length - Code block too long  - length =", account_number_length)
      )
    )
  
  transaction_report <- transaction_report %>%
    filter(stri_length(account_number) == 19)
  
  # 4. check for valid form. ie: ##-###-####-####-###-#### ---------------------
  
  invalid_form <-
    transaction_report %>%
    filter(!str_detect(
      .$account_number,
      regex("^[:digit:]{3}-[:digit:]{6}-[:digit:]{8}$")
    )) %>% 
    mutate(
      reason = "Invalid Form - form must be : ###-######-########"
    )
  
  # transaction_report <-
  #   transaction_report %>%
  #   filter(str_detect(
  #     .$account_number,
  #     regex("^[:digit:]{3}-[:digit:]{6}-[:digit:]{8}$")
  #   ))
  # 
  # I think an anti-join will be faster than filter
  
  transaction_report <- transaction_report %>% 
    anti_join(invalid_form, by = "id")
  
  #5. enrich the transaction_report --------------------------------------------
  
  transaction_report <- transaction_report %>%
    mutate(
      fund                    = .[["account_number"]] %>% substr(0, 3),
      funct                   = .[["account_number"]] %>% substr(5, 10),
      account                 = .[["account_number"]] %>%  substr(12, 19),
      fund_code_primary       = str_sub(fund, 0, 2),
      fund_code_secondary     = str_sub(fund, 2, 3),
      funct_code_primary      = str_sub(funct, 0, 2),
      funct_code_secondary    = str_sub(funct, 3, 4),
      funct_code_tertiary     = str_sub(funct, 5, 6),
      account_code_primary    = str_sub(account, 0, 2),
      account_code_secondary  = str_sub(account, 3, 4),
      account_code_tertiary   = str_sub(account, 5, 6),
      account_code_quaternary = str_sub(account, 7, 8)
    ) %>%
    
    # Now we need to join ucoa.xlsx, so we know what the codes mean.
    
    # join the funds
    left_join(
      lookup_table %>%
        pluck("fund") %>%
        as_tibble() %>%
        select(
          number,
          fund_description = description,
          fund_level_primary = level_primary,
          fund_level_secondary = level_secondary
        ),
      by = c("fund" = "number")
    ) %>%
    # join the functions
    left_join(
      lookup_table %>%
        pluck("funct") %>%
        as_tibble() %>%
        select(
          number,
          funct_description = description,
          funct_level_primary = level_primary,
          funct_level_secondary = level_secondary,
          funct_level_tertiary = level_tertiary
        ),
      by = c("funct" = "number")
    ) %>%
    # join the accounts
    left_join(
      lookup_table %>%
        pluck("account") %>%
        as_tibble() %>%
        select(
          number,
          account_description = description,
          account_level_primary = level_primary,
          account_level_secondary = level_secondary,
          account_level_tertiary = level_tertiary
        ),
      by = c("account" = "number")
    )
  
  #6. Filter out any non revenue and expense uca -------------------------------
  
  # stimexp <- transaction_report %>%
  #   filter(type == 4) %>%
  #   mutate(type=type,
  #          transaction_type = "stimulus expense",
  #          reason = "Invalid Transaction Type - transaction type correpsonds to stimulus expense(must be a Revenue or Expense).")
  # 
  # stimrev <- transaction_report %>%
  #   filter(type == 5) %>%
  #   mutate(type=type,
  #          transaction_type = "stimulus revenue",
  #          reason = "Invalid Transaction Type - transaction type correpsonds to stimulus revenue(must be a Revenue or Expense).")
  # 
  # budget <- transaction_report %>%
  #   filter(type == 6) %>%
  #   mutate(type=type,
  #          transaction_type = "budget",
  #          reason = "Invalid Transaction Type - transaction type correpsonds to budget (must be a Revenue or Expense).")
  # 
  # balance_sheet <- transaction_report %>%
  #   filter(type == 7) %>%
  #   mutate(type=type,
  #          transaction_type = "balance sheet",
  #          reason = "Invalid Transaction Type - transaction type correpsonds to balance sheet (must be a Revenue or Expense).")
  # 
  # invalid_transaction_type <- stimexp %>%
  #   bind_rows(stimrev) %>%
  #   bind_rows(budget) %>%
  #   bind_rows(balance_sheet)
  # 
  # transaction_report<- transaction_report %>%
  #    anti_join(stimexp, by="id")%>%
  #    anti_join(stimrev, by="id")%>%
  #    anti_join(budget, by="id")%>%
  #    anti_join(balance_sheet, by="id")

  #get all the accounts that start with a 1 or a 2. These are not acceptable uca according to Darell. 
  # rev_begin_with1 <- transaction_report %>%
  #   filter(type == 2 && str_sub(account, 0, 1) == 1) %>%
  #   mutate(reason = "Invalid Account block - account block starts with 1 - Account chunk must start with a 3 (revenue) or 4 (expenditure).")
  # 
  # exp_begin_with1 <- transaction_report %>%
  #   filter(type == 1 && str_sub(account, 0, 1) == 1) %>%
  #   mutate(reason = "Invalid Account block - account block starts with 1 - Account chunk must start with a 3 (revenue) or 4 (expenditure).")
  # 
  # rev_begin_with2 <- transaction_report %>%
  #   filter(type == 2 && str_sub(account, 0, 1) == 2) %>%
  #   mutate(reason = "Invalid Account block - account block starts with 2 - Account chunk must start with a 3 (revenue) or 4 (expenditure).")
  # 
  # exp_begin_with2 <- transaction_report %>%
  #   filter(type == 1 && str_sub(account, 0, 1) == 2) %>%
  #   mutate(reason = "Invalid Account block - account block starts with 2 - Account chunk must start with a 3 (revenue) or 4 (expenditure).")

  # invalid_account_type <- rev_begin_with1 %>%
  #   bind_rows(exp_begin_with1)%>%
  #   bind_rows(rev_begin_with2)%>%
  #   bind_rows(exp_begin_with2)
  #   
  
  # invalid_account_type <- transaction_report %>%
  #   filter((type == 1 || type ==2) && (str_sub(account, 0, 1) == 1 ||str_sub(account, 0, 1) == 2)) %>%
  #   mutate(reason = "Invalid Account block - Account chunk must start with a 3 (revenue) or 4 (expenditure).")
  
  invalid_account_type <- transaction_report %>%
    # filter((str_sub(account, 0, 1) == 1  & type == 1) |
    #          (str_sub(account, 0, 1) == 1  & type == 2) |
    #          (str_sub(account, 0, 1) == 2  & type == 1) |
    #          (str_sub(account, 0, 1) == 2  & type == 1)
    # ) %>%
    filter((str_sub(account, 0, 1) == 1) |
             (str_sub(account, 0, 1) == 1) |
             (str_sub(account, 0, 1) == 2) |
             (str_sub(account, 0, 1) == 2)) %>% 
    mutate(reason = "Invalid Account Chunk - Account chunk must start with a 3 (revenue) or 4 (expenditure).")

  transaction_report<- transaction_report %>%
     anti_join(invalid_account_type, by="id")
  
  
  #7. Find unmapped uca codes --------------------------------------------------
  
  #find wrong fund code
  unmapped_fund_code <- transaction_report %>%
    filter(!fund %in% (lookup_table %>%
                         pluck("fund")  %>%
                         select(number) %>%
                         unlist())) %>%
    select(
      id,
      batch_id,
      amount,
      type,
      fiscal_year,
      account_number,
      fund,
      fund_code_primary,
      fund_code_secondary
    ) %>% 
    mutate(
      reason = "Invalid Fund Code - The fund code does not exist in the current uniform chart of accounts. "
    )
  
  #If the fund code does not map, we want to know which component of the code
  #failed. ie: was it the primary or secondary component?
  
  # check primary
  unmapped_fund_code_primary <- unmapped_fund_code %>%
    filter(!fund_code_primary %in% (
      lookup_table %>%
        pluck("fund")  %>%
        select(code_primary) %>%
        unlist()
    ))%>% 
    mutate(
      reason = "Invalid Fund Code - The primary piece of the fund code does not exist in the current uniform chart of accounts. "
    )
  
  #check secondary
  unmapped_fund_code_primary <- unmapped_fund_code %>%
    filter(!fund_code_primary %in% (
      lookup_table %>%
        pluck("fund")  %>%
        select(code_primary) %>%
        unlist()
    )) %>% 
    mutate(
      reason = "Invalid Fund Code - The secondary piece the fund code does not exist in the current uniform chart of accounts. "
    )
  
  
  #find wrong function code
  unmapped_funct_code <- transaction_report %>%
    filter(!funct %in% (
      lookup_table %>%
        pluck("funct") %>%
        select(number) %>%
        unlist()
    )) %>%
    select(
      id,
      batch_id,
      amount,
      type,
      fiscal_year,
      account_number,
      funct,
      funct_code_primary,
      funct_code_secondary,
      funct_code_tertiary
    ) %>%
    mutate(reason = "Invalid Function Code - The function code does not exist in the current uniform chart of accounts. ")
  
  #If the funct code does not map, we want to know which component of the code
  #failed. ie: was it the primary, secondary, or tertiary component?
  
  #check funct primary
  unmapped_funct_code_primary <- unmapped_funct_code %>%
    filter(!funct_code_primary %in% (
      lookup_table %>%
        pluck("funct")  %>%
        select(code_primary) %>%
        unlist()
    )) %>%
    mutate(reason = "Invalid Function Code - The first and/or second digits of the function code do not exist in the current uniform chart of accounts. ")
  
  
  #check funct secondary
  unmapped_funct_code_secondary <- unmapped_funct_code %>%
    filter(
      funct_code_primary %in% (
        lookup_table %>%
          pluck("funct")  %>%
          select(code_primary) %>%
          unlist()
      )
      ,
      !funct_code_secondary %in% (
        lookup_table %>%
          pluck("funct")  %>%
          select(code_secondary) %>%
          unlist()
      )
    ) %>%
    mutate(reason = "Invalid Function Code - The third and/or fourth digits of the function code do not exist in the current uniform chart of accounts. ")
  
  
  # check funct tertiary
  unmapped_funct_code_tertiary <- unmapped_funct_code %>%
    filter(
      funct_code_primary %in% (
        lookup_table %>%
          pluck("funct")  %>%
          select(code_primary) %>%
          unlist()
      )
      ,
      funct_code_secondary %in% (
        lookup_table %>%
          pluck("funct")  %>%
          select(code_secondary) %>%
          unlist()
      )
      ,
      !funct_code_tertiary %in% (
        lookup_table %>%
          pluck("funct")  %>%
          select(code_tertiary) %>%
          unlist()
      )
    ) %>%
    mutate(reason = "Invalid Function Code - The fifth and/or sixth digits of the function code do not exist in the current uniform chart of accounts. ")
  
  # check account
  unmapped_account_code <- transaction_report %>%
    filter(!account %in% (
      lookup_table %>%
        pluck("account") %>%
        select(number)   %>%
        unlist()
    )) %>%
    select(
      id,
      batch_id,
      amount,
      type,
      fiscal_year,
      account_number,
      account,
      account_code_primary,
      account_code_secondary,
      account_code_tertiary,
      account_code_quaternary
    )%>%
    mutate(reason = "Invalid Account Code - The account code does not exist in the current uniform chart of accounts. ")
  
  #If the funct code does not map, we want to know which component of the code
  #failed. ie: was it the primary, secondary, tertiary, quaternary component?
  
  #check account primary
  unmapped_account_code_primary <- unmapped_account_code %>%
    filter(!account_code_primary %in% (
      lookup_table %>%
        pluck("account")  %>%
        select(code_primary) %>%
        unlist()
    )) %>% 
    mutate(reason = "Invalid Account Code - The first and/or second digits of account code do not exist in the current uniform chart of accounts. ")
  
  
  #check account secondary
  unmapped_account_code_secondary <- unmapped_account_code %>%
    filter(
      account_code_primary %in% (
        lookup_table %>%
          pluck("account")  %>%
          select(code_primary) %>%
          unlist()
      ),
      !account_code_secondary %in% (
        lookup_table %>%
          pluck("account")  %>%
          select(code_secondary) %>%
          unlist()
      )
    )%>%
    mutate(reason = "Invalid Account Code - The third and/or fourth digits of the account code do not exist in the current uniform chart of accounts. ")
  
  
  unmapped_account_code_tertiary <- unmapped_account_code %>%
    filter(
      account_code_primary %in% (
        lookup_table %>%
          pluck("account")  %>%
          select(code_primary) %>%
          unlist()
      ),
      account_code_secondary %in% (
        lookup_table %>%
          pluck("account")  %>%
          select(code_secondary) %>%
          unlist()
      ),
      !account_code_tertiary %in% (
        lookup_table %>%
          pluck("account")  %>%
          select(code_tertiary) %>%
          unlist()
      )
    )%>%
    mutate(reason = "Invalid Account Code - The fifth and/or sixth digits of the account code do not exist in the current uniform chart of accounts. ")
  
  unmapped_account_code_quaternary <- unmapped_account_code %>%
    filter(
      account_code_primary %in% (
        lookup_table %>%
          pluck("account")  %>%
          select(code_primary) %>%
          unlist()
      ),
      account_code_secondary %in% (
        lookup_table %>%
          pluck("account")  %>%
          select(code_secondary) %>%
          unlist()
      ),
      account_code_tertiary %in% (
        lookup_table %>%
          pluck("account")  %>%
          select(code_tertiary) %>%
          unlist()
      )#,
      # !account_code_quaternary %in% (
      #   lookup_table %>%
      #     pluck("account")  %>%
      #     select(code_quaternary) %>%
      #     unlist()
      # )
    )%>%
    mutate(reason = "Invalid Account Code - The seventh and/or eighth digits of the account code do not exist in the current uniform chart of accounts. ")
  
  #now remove incorrectly mapped. we will save them to report, but do not want
  #them in our analysis.
  transaction_report <- transaction_report %>%
    anti_join(unmapped_fund_code, by = "id") %>%
    anti_join(unmapped_funct_code, by = "id") %>%
    anti_join(unmapped_account_code, by = "id")
  
  #8. check account type -------------------------------------------------------
  
  # finally check that the account is mapped to the transaction type 
  # 1 = expediture
  # 2 = revenue
  
  exp_transaction_but_rev_account <- transaction_report %>%
    filter(type == 1 & str_sub(account, 0, 1) == 3)%>%
    mutate(reason = "Invalid Account Code or Transaction Type - the transaction is listed as an expenditure, but has an account code correpsonding to a revenue ") %>% 
    select(
      id,
      batch_id,
      amount,
      type,
      fiscal_year,
      account_number,
      account,
      reason
    )

  rev_transaction_but_exp_account <- transaction_report %>%
    filter(type == 2 & str_sub(account, 0, 1) == 4)%>%
    mutate(reason = "Invalid Account Code or Transaction Type - the transaction is listed as a revenue, but has an account code correpsonding to a expenditure ") %>%
    select(
      id,
      batch_id,
      amount,
      type,
      fiscal_year,
      account_number,
      account,
      reason
    )
  
  transaction_report <- transaction_report %>% 
    anti_join(exp_transaction_but_rev_account, by = "id") %>% 
    anti_join(rev_transaction_but_exp_account, by = "id")
  

  # Deal with NOT Applicable Function Code. We need to filter these out now. 
  
  rev_invalid_function_use <- transaction_report %>%
    filter( type == 2 & funct == "000000") %>%
    mutate(reason = "Invalid Function Code - The 'Not Applicable' function code (000000) is no longer acceptable. Fix by listing an appropriate function code.")
  
  
  exp_invalid_function_use <- transaction_report %>%
    filter(type == 1  & funct == "000000") %>%
    mutate(reason = "Invalid Function Code - The 'Not Applicable' function code (000000) is no longer acceptable. Fix by listing an appropriate function code.")
  
  invalid_function_use <- rev_invalid_function_use %>% bind_rows(exp_invalid_function_use)
  
  transaction_report<- transaction_report %>% 
    anti_join(invalid_function_use, by="id")
  

  #now create a tibble which can let us know if there are errors present.
  if(transaction_report %>% nrow()==0){no_transactions = TRUE }else{no_transactions= FALSE}
  if(invalid_reported_na %>% nrow()>0){fail_na = TRUE }else{fail_na= FALSE}
  if(invalid_length %>% nrow()>0){fail_length = TRUE }else{fail_length = FALSE}
  if(invalid_form %>% nrow()>0){fail_form = TRUE }else{fail_form =FALSE}
#  if(invalid_transaction_type %>% nrow()>0){fail_transaction_type = TRUE }else{fail_transaction_type =FALSE}
  if(invalid_account_type %>% nrow()>0){fail_account_type = TRUE }else{fail_account_type =FALSE}
  if(unmapped_fund_code %>% nrow()>0){fail_fund = TRUE }else{fail_fund = FALSE}
  if(unmapped_funct_code %>% nrow()>0){fail_funct = TRUE }else{fail_funct =FALSE}
  if(unmapped_funct_code_primary %>% nrow()>0){fail_funct_pri = TRUE }else{fail_funct_pri =FALSE}
  if(unmapped_funct_code_secondary %>% nrow()>0){fail_funct_sec = TRUE }else{fail_funct_sec =FALSE}
  if(unmapped_funct_code_tertiary %>% nrow()>0){fail_funct_ter = TRUE }else{fail_funct_ter =FALSE}
  if(unmapped_account_code %>% nrow()>0){fail_account = TRUE }else{fail_account = FALSE}
  if(unmapped_account_code_primary %>% nrow()>0){fail_account_pri = TRUE }else{fail_account_pri =FALSE}
  if(unmapped_account_code_secondary %>% nrow()>0){fail_account_sec = TRUE }else{fail_account_sec =FALSE}
  if(unmapped_account_code_tertiary %>% nrow()>0){fail_account_ter = TRUE }else{fail_account_ter =FALSE}
  if(unmapped_account_code_quaternary %>% nrow()>0){fail_account_qua = TRUE }else{fail_account_qua = FALSE}
  if(exp_transaction_but_rev_account %>% nrow()>0){fail_exp_as_rev = TRUE }else{fail_exp_as_rev =FALSE}
  if(rev_transaction_but_exp_account %>% nrow()>0){fail_rev_as_exp = TRUE }else{fail_rev_as_exp =FALSE}
  if(invalid_function_use %>% nrow()>0){fail_na_function_use = TRUE }else{fail_na_function_use =FALSE}

  summary_tibble <- tibble(

    name = c(
      "transaction_report",
      "invalid_reported_na",
      "invalid_length",
      "invalid_form",
#      "fail_transaction_type",
      "fail_account_type",
      "unmapped_fund_code",
      "unmapped_funct_code",
      "unmapped_funct_code_primary",
      "unmapped_funct_code_secondary",
      "unmapped_funct_code_tertiary",
      "unmapped_account_code",
      "unmapped_account_code_primary",
      "unmapped_account_code_secondary",
      "unmapped_account_code_tertiary",
      "unmapped_account_code_quaternary",
      "exp_transaction_but_rev_account",
      "rev_transaction_but_exp_account",
      "fail_na_function_use"
    ),

    status = c(
      no_transactions,
      fail_na,
      fail_length,
      fail_form,
#      fail_transaction_type,
      fail_account_type,
      fail_fund,
      fail_funct,
      fail_funct_pri,
      fail_funct_sec,
      fail_funct_ter,
      fail_account,
      fail_account_pri,
      fail_account_sec,
      fail_account_ter,
      fail_account_qua,
      fail_exp_as_rev,
      fail_rev_as_exp,
      fail_na_function_use
    )

  )
  
  
  
  # consolidate ----------------------------------------------------------------
  entity_info <-
    list(
      "transaction_report" = transaction_report,                            #1
      "invalid_reported_na" = invalid_reported_na,                          #2  
      "invalid_length" = invalid_length,                                    #3 
      "invalid_form" = invalid_form,                                        #4
      "unmapped_fund_code" = unmapped_fund_code,                            #5 
      "unmapped_funct_code" = unmapped_funct_code,                          #6 
      "unmapped_funct_code_primary" = unmapped_funct_code_primary,          #7
      "unmapped_funct_code_secondary" = unmapped_funct_code_secondary,      #8
      "unmapped_funct_code_tertiary" = unmapped_funct_code_tertiary,        #9
      "unmapped_account_code" = unmapped_account_code,                      #10
      "unmapped_account_code_primary" = unmapped_account_code_primary,      #11
      "unmapped_account_code_secondary" = unmapped_account_code_secondary,  #12
      "unmapped_account_code_tertiary" = unmapped_account_code_tertiary,    #13
      "unmapped_account_code_quaternary" = unmapped_account_code_quaternary,#14
      "exp_transaction_but_rev_account" = exp_transaction_but_rev_account,  #15
      "rev_transaction_but_exp_account" = rev_transaction_but_exp_account,
#      "invalid_transaction_type" = invalid_transaction_type,
      "invalid_account_type" = invalid_account_type,
      "invalid_function_use" = invalid_function_use,
      "summary_tibble" = summary_tibble
      
    ) #%>% enframe()
}

```

### extract_summary_tibble
```{r}
extract_summary_tibble <- function(entity_name, report_df){
  report_df <- report_df %>% 
    filter(name == entity_name) %>% 
    pull(queried_transactions) %>% 
    pluck(1) %>% 
    pluck("summary_tibble")
  
}
```

### extract_summary_tibble_errors
```{r}
extract_summary_tibble_errors <- function(entity_name, report_df){
    report_df <- report_df %>% 
    filter(name == entity_name)
  
  if(report_df %>% 
    pull(queried_transactions) %>% 
    pluck(1) %>% 
    pluck("summary_tibble") %>% 
    filter(status=="TRUE") %>% 
    nrow() > 0){
    wrong_types <- report_df %>%
      pull(queried_transactions) %>%
      pluck(1) %>%
      pluck("summary_tibble") %>%
      filter(status == "TRUE") %>%
      pull(name) %>% 
      paste(., collapse = ', ')
  }else{
      wrong_types <- paste("no_errors")
    }
  
}
```

### pluck_queried_transactions
```{r}
pluck_queried_transactions <- function(entity_name, report_df){
      report_df %>% 
      filter(name==entity_name) %>%
      pull(queried_transactions) %>%
      pluck(1) 
}
```

### standard_export_form

```{r}
standard_export_form <- function(report_df){
  report_df %>%  mutate(
      transaction_type = case_when(
        type == 1 ~ "expenditure",
        type == 2 ~ "revenue",
        type == 3 ~ "employee compensation",
        type == 4 ~ "stimulus expense",
        type == 5 ~ "stimulus revenue",
        type == 6 ~ "budget",
        type == 7 ~ "balance sheet"
      )
    ) %>%
    select(
      fiscal_year,
      batch_id,
      "transaction_id" = id,
      amount,
      type,
      transaction_type,
      account_number,
      #account_number_length,
      reason,
    )
}
```

# III. Load Reference tables 
## A. Load Lookup Table

```{r}
osa_lookup_file_name <- "osa_lookup.xlsx"

osa_lookup <- excel_sheets(osa_lookup_file_name) %>%
  map(read_excel, path = osa_lookup_file_name)

names(osa_lookup) <- c("fund", "funct", "account")

rm(osa_lookup_file_name)

```

browse the lookup tables
```{r,eval = FALSE}
osa_lookup
```

##B.Load Salesforce Data

```{r}
sf_entity_info <- 
  dbGetQuery(
    odbc_sf,
    "SELECT 
      a.Name                          AS name,
      a.Id                            AS id,
      a.Transparency_ID__c            AS t_id,
      a.Fiscal_Year_Begins__c         AS begin_fy,
      a.Expense_Revenue_Start_Date__c AS begin_report_er, 
      a.Wage_Start_Date__c            AS begin_report_w2,
      r.Name AS govt_type
    FROM Account         AS a
    LEFT JOIN RecordType AS r
      ON a.RecordTypeId = r.Id
    WHERE a.RecordTypeId IN (
      SELECT Id
      FROM RecordType
      WHERE SobjectType = 'Account'
      AND IsActive = 'TRUE'
      AND Name NOT IN (
        'Community User',
        'Component', -- This govt type contains local governments, but not ones for which we enforce compliance.
        'Court (Search Under Parent Entity)',
        'CPA Firm',
        'Educational Foundation or Component Unit', -- Not an entity we review for compliance.
        'Financial Institution',
        'Health Provider',
        'Non Profits'))
    AND a.Name NOT IN (
      'Intermountain Power Agency',
      'test city 2',
      'Utah Associated Municipal Power Systems',
      'Utah Municipal Power Agency')
    AND Entity_Status__c NOT IN ('Inactive', 'Dissolved')
    AND (
      a.Expense_Revenue_Start_Date__c <= DATE() OR
      a.Expense_Revenue_Start_Date__c IS NULL)") %>% 
  as_tibble() %>% 
  mutate(
  govt_type = 
    if_else(
      name %in% 
        c("State of Utah",
          "Utah System of Higher Education - Student Loan Guarantee Program",
          "Utah System of Higher Education - Student Loan Purchase Program",
          "Utah System of Higher Education - Utah Educational Savings Plan dba my529",
          "Utah System of Higher Education - Utah State Board of Regents"),
      "Monitored State Agency",
      govt_type)) %>% 
  filter(govt_type != "State of Utah (agencies/depts/comp units/ etc.)") %>% 
  # The State of Utah is required to report to Transparent Utah, but in most instances we do not monitor its data:
  filter(name != "State of Utah") #%>% 
  #select(-govt_type)

sf_exemptions <- 
  dbGetQuery(
    odbc_sf,
    paste("
          SELECT 
            a.Name                          AS name,
            t.Account__c                    AS id,
            a.Fiscal_Year_Begins__c         AS begin_fy,
            t.Transparency_type_exempted__c AS transaction_type,
            t.Recurring_Exemption__c        AS recurring_exemption,
            t.Exemption_Start_Date__c       AS exemption_start,
            t.Exemption_End_Date__c         AS exemption_end,
            t.Permanent_or_Temporary__c     AS exemption_type,
            t.Exemption_Reason__c           AS reason
          FROM (
            SELECT 
              Account__c,
              Exemption_Start_Date__c,
              Exemption_End_Date__c,
              Recurring_Exemption__c,
              Transparency_type_exempted__c,
              Permanent_or_Temporary__c,
              Exemption_Reason__c
            FROM Transparency_Exemption__c
            WHERE IsDeleted = FALSE) t
          LEFT JOIN Account a
          ON t.Account__c = a.Id
          WHERE a.Entity_Status__c IN (
            'Current', 
            'On hold', 
            'Delinquent', 
            'Suspended')
          AND a.Name != 'test city 2'")) %>% 
  as_tibble()

```

### 1.Validate the salesforce data
```{r}
validate_nrow(sf_entity_info, 1000)

# Validate sf_entity_info ####

if (class(sf_entity_info$name)            != "character" ||
    class(sf_entity_info$id)              != "character" ||
    class(sf_entity_info$t_id)            != "numeric"   ||
    class(sf_entity_info$begin_fy)        != "Date"      ||
    class(sf_entity_info$begin_report_er) != "Date"      ||
    class(sf_entity_info$begin_report_w2) != "Date") {

  stop("One or more fields in sf_entity_info is not of the correct class.
       Review the data before continuing.",
       call. = FALSE)  
}

if (sf_entity_info %>% 
    filter(is.na(name) | is.na(id)) %>% 
    nrow() > 0) {

  name_or_id_is_na <- 
    sf_entity_info %>% 
    filter(is.na(name) | is.na(id))
  
  stop("Entities should have a name and Salesforce ID.
       A missing name or Salesforce ID indicates some larger problem with the 
       data. Review and correct before continuing.",
       call. = FALSE)
}

if (sf_entity_info %>% 
    filter(is.na(begin_fy)) %>% 
    nrow() > 0) {
  
  missing_begin_fy <- 
    sf_entity_info %>% 
    filter(is.na(begin_fy))
  
  stop("begin_fy should be populated for every active government. Update 
       Salesforce and reimport before continuing.", call. = FALSE)
    }

if (sf_entity_info %>% 
    filter(
      !is.na(t_id) & (
        is.na(begin_report_er) |
        is.na(begin_report_w2))) %>% 
    nrow() > 0) {
  
  incomplete_info <- 
    sf_entity_info %>% 
    filter(
      !is.na(t_id) & (
        is.na(begin_report_er) |
        is.na(begin_report_w2)))
  
  stop("Entities with a Transparency ID must also have non-NA values for 
       begin_report_er and begin_report_w2 in
       order to determine their compliance status.",
       call. = FALSE)
}

if (sf_entity_info %>% 
    filter(begin_fy > today()) %>%
    nrow() > 0) {
  
  future_begin_fy <- 
    sf_entity_info %>% 
    filter(begin_fy > today())
  
  stop("Entities must not have a begin_fy value in the future.
       Correct and reimport before continuing.",
       call. = FALSE)
}

if (sf_entity_info %>% 
    filter(begin_fy <= (today() - months(12))) %>% 
    nrow() > 0) {
  
  sf_entity_info$begin_fy <- 
    sf_entity_info$begin_fy %>% 
    map_dbl(make_current_begin_fy)
  
  class(sf_entity_info$begin_fy) <- "Date"
}

if (sf_entity_info %>% 
    filter(month(begin_report_er) != month(begin_fy)) %>% 
    nrow() > 0) {
  
  begin_report_er_month_is_wrong <- 
    sf_entity_info %>% 
    filter(month(begin_report_er) != month(begin_fy))
  
  stop("The month of begin_report_er must match the month of begin_fy.
       Update in Salesforce (create an exemption if necessary) and reimport.",
       call. = FALSE)
}

if (sf_entity_info %>% 
    filter(month(begin_report_w2) != month(begin_fy)) %>% 
    nrow() > 0) {
  
  begin_report_w2_month_is_wrong <- 
    sf_entity_info %>% 
    filter(month(begin_report_w2) != month(begin_fy))
  
  stop("The month of begin_report_w2 must match the month of begin_fy.
       Update in Salesforce (create an exemption if necessary) and reimport.",
       call. = FALSE)
}

if (sf_entity_info %>% 
    filter(begin_report_w2 < begin_report_er) %>% 
    nrow() > 0) {
  
  w2_date_prior_to_exp_rev <- 
    sf_entity_info %>% 
    filter(begin_report_w2 < begin_report_er)
  
  stop("begin_report_w2 should not be earlier than
       begin_report_er. Update in Salesforce and reimport.", 
       call. = FALSE)
}
```

# IV. Execute:

## 1. Get batches
note: takes about one minute
```{r}
#start_time <- Sys.time()

report <- sf_entity_info %>% 
  # filter(!is.na(t_id))  %>% 
  # filter(govt_type != "School District or Charter School") %>% 
  mutate(batches = map(t_id ,query_batch_ids))# %>% 
  # rowwise() %>% 
  # filter(batches %>% length() != 0) %>% 
  # mutate(name = str_replace(name, "/"," "))

#end_time <- Sys.time()
#time_elapsed_query_batch_ids <- end_time - start_time
#time_elapsed_query_batch_ids
```

###  Clean: Remove entities without t-Id
```{r}
report_missing_t_id <- report %>%
  filter(is.na(t_id))
report <- report %>% anti_join(report_missing_t_id, by = "id")
```

### Clean: Remove entities without batches
```{r}
report_empty_batches <- report  %>%
  rowwise() %>%
  filter(batches %>% length() == 0)

report <- report %>% anti_join(report_empty_batches , by = "id")
```

### Clean: for right now get rid of all school districts
```{r}
report_schools <- report %>%
  filter(govt_type == "School District or Charter School" | 
           govt_type == "Institution of Higher Education" | 
           govt_type == "Monitored State Agency")

report <- report %>%
  anti_join(report_schools, by="id")
```

### Clean : take out counties because they are massive. Will run analysis separetely. 
```{r}
report_county <- report %>% 
  filter(govt_type == "County")

report <- report %>% 
  anti_join(report_county, by = "id")
```

### Clean: fix names with a "/" in the name
```{r}
report <- report %>%
  mutate(name = str_replace(name, "/"," "))
```



## 2. Validate - non counties

for each entity, take the list of batches and run the query_transaction function on the batches. 

## WARNING!!! this takes about 33 minutes to complete! 

```{r}
#start_time <- Sys.time()

report <- report %>% 
  filter(govt_type == "City") %>% 
  slice(1:60) %>% 
  #slice(1:30) %>%  #uncomment/comment to run a subset. 
  mutate(queried_transactions = batches %>% map(query_and_validate_transactions, osa_lookup))

#end_time <- Sys.time()

#time_elapsed_query_transactions <- end_time - start_time
```

```{r}
report <- report %>% 
  rowwise() %>% 
  mutate(
    uca_summary = name %>% map_chr(extract_summary_tibble_errors,report)
  )
```

```{r,eval = FALSE}
report %>% head()
```

```{r}
good_uca_entities <- report %>% 
  filter(uca_summary == "no_errors")
```

entities_with_no_transactions

```{r}
entities_with_no_transactions <- report %>% 
  filter(uca_summary == "transaction_report")
```

```{r}
bad_uca_entities <- report %>%  
  filter(uca_summary != "no_errors" & uca_summary != "transaction_report")
```



#V. Develop a Data Quality Index
## functions
### find_perc_of_valid_transactions
```{r}
find_perc_of_valid_transactions <- function(entity_name,report_df){
  #Inputs:
    #-entity_name(chr): an entities name
    #-report_df(tibble): an report dataframe
  
  #Outputs: double
  
  #Description: calculates the number of valid single item transactions divided by the total number of transactions. This is meant to be a useful mark in determing how erroronous the data is.
  
  queried_transactions_list <- report_df %>% 
    filter(name == entity_name) %>% 
    pluck("queried_transactions")
  
  transaction_report_valid <- queried_transactions_list %>%
    pluck(1,"transaction_report") %>%
    select(id)
  
  temp_seq <- seq(from = 2 , to = 17, by = 1)
  
  transaction_report_invalid <- tibble()
  
  for (temp_tib_index in temp_seq) {
    invalid_tib <- queried_transactions_list %>%
      pluck(1,temp_tib_index) %>%
      select(id)
    
    transaction_report_invalid <-
      rbind(transaction_report_invalid, invalid_tib)
  }
  
  nrow_valid <- transaction_report_valid %>% nrow()

  nrow_invalid <- transaction_report_invalid %>% nrow()

  perc_invalid <- paste(nrow_valid / (nrow_invalid + nrow_valid),"%")
  
}
```
###find_dollar_of_valid_transactions
```{r}
find_dollar_of_valid_transactions <- function(entity_name,report_df){
  #Inputs: 
    #-entity_name(chr): an entities name
    #-report_df(tibble): an report dataframe
  
  #Outputs: list
  
  #Description: calculates the dollar amount of valid vs invalid transactions
  queried_transactions_list <- report_df %>% 
    filter(name == entity_name) %>% 
    pluck("queried_transactions")
  
  transaction_report_valid <- queried_transactions_list %>%
    pluck(1,"transaction_report") %>%
    select(amount)
  
  temp_seq <- seq(from = 2 , to = 17, by = 1)
  
  transaction_report_invalid <- tibble()
  
  for (temp_tib_index in temp_seq) {
    invalid_tib <- queried_transactions_list %>%
      pluck(1,temp_tib_index) %>%
      select(amount)
    
    transaction_report_invalid <-
      rbind(transaction_report_invalid, invalid_tib)
  }
  
  sum_valid <- transaction_report_valid %>% pull(amount) %>% sum()

  sum_invalid <- transaction_report_invalid %>% pull(amount) %>% sum()

  perc_sum_invalid <- sum_valid / (sum_invalid + sum_valid)
  
  list(
    sum_valid = paste("$",prettyNum(sum_valid,big.mark=",",scientific=FALSE)),
    sum_invalid = paste("$",prettyNum(sum_invalid,big.mark=",",scientific=FALSE)),
    perc_sum_invalid = paste(perc_sum_invalid,"%")
  )
  
}
```


###clean_transaction_report
```{r}
clean_transaction_report <- function(tr_df) {
  tr_df <- tr_df %>%
    filter(fiscal_year != 2020) %>%
    transmute(
      id                  = as.double(id),
      batch_id            = as.double(batch_id),
      fiscal_year         = factor(
                              fiscal_year,
                              levels = c("2014", "2015", "2016", "2017", "2018", "2019", "2020"),
                              ordered = TRUE
                            ),
      amount              = as.double(amount),
      account_number      = as.character(account_number),
      type                = as.integer(type),
      fund                = as.integer(fund),
      funct               = as.integer(funct),
      account             = as.integer(account),
      fund_description    = factor(fund_description),
      funct_description   = factor(funct_description),
      account_description = factor(account_description),
    )
}
```

###compute_rev_exp_stats
```{r}
compute_rev_exp_stats <- function(tr_df, ...) {
  #Inputs:
    #tr_df (tibble) : transaction dataframe
  #Outputs:
    #agg_report (tibble): aggregated report
  #Descrition:
    #compute the rev/exp net amounts and the number of them, and the difference given a set of grouping variables.
  
  group_var <- enquos(...)
  
  agg_report <- tr_df %>%
    group_by(!!!group_var) %>%
    summarise(
      rev = sum(if_else(type == 2, amount, 0)),
      rev_n = sum(if_else(type == 2, 1, 0)),
      exp = sum(if_else(type == 1, amount, 0)),
      exp_n = sum(if_else(type == 1, 1, 0))
    ) %>%
    mutate(
      rev_minus_exp = rev - exp,
      sord =  if_else(rev_minus_exp >= 0, "surplus", "deficit")
    ) %>% 
    mutate(
      perc_of_type = case_when(
        rev_minus_exp >= 0 ~ rev_minus_exp/rev,
        rev_minus_exp  < 0 ~ rev_minus_exp/exp
      ),
      perc_of_total = rev_minus_exp / (rev + exp),
      yearly_diff_rme = rev_minus_exp- lag(rev_minus_exp,1),
      yearly_diff_rme_perc = (rev_minus_exp- lag(rev_minus_exp,1))/(rev_minus_exp+ lag(rev_minus_exp,1))
    ) 
}
```
###calculate_CAGRs
```{r}
calculate_CAGRs <- function(yearly_stats){
  #Inputs:
    #yearly_stats (tibble) : a yearly aggregated dataframe. It has been wrangled through the compute_rev_exp_stats function. 
  #Outputs:
    #list: a list of interesting stats like the revenue CAGR, the expenditure CAGR, and a string of which is larger.
  #Descrition:
    #compute the Compounded Annual Growth Rate for Revenue and Expenditures at a year level.   
    
  min_year <- yearly_stats %>% pull(fiscal_year) %>% unique() %>% min()
  max_year <- yearly_stats %>% pull(fiscal_year) %>% unique() %>% max()
  diff_year <- as.numeric(max_year)-as.numeric(min_year)
  
  CAGR_rev <-
  (
    yearly_stats %>%
      filter(fiscal_year == max_year) %>%
      pull(rev) / 
      yearly_stats %>% 
      filter(fiscal_year == min_year) %>%
      pull(rev)
  ) ^ (1 / diff_year) - 1
  
  CAGR_exp <-
  (
    yearly_stats %>%
      filter(fiscal_year == max_year) %>%
      pull(exp) / 
      yearly_stats %>% 
      filter(fiscal_year ==  min_year) %>% 
      pull(exp)
  ) ^ (1 / diff_year) - 1

  if(CAGR_rev >= CAGR_exp){
    status <- "rev > exp"
  }else{
    status <- "exp > rev"
  }
  
  temp_list <- list(
    "CAGR_rev" = CAGR_rev,
    "CAGR_exp" = CAGR_exp,
    "status"   = status
  )  
  
}

```
### rev_minus_exp_barplot
```{r}
rev_minus_exp_barplot <- function(df, xvar, yvar,fillvar){
  
    #Inputs:
    #- df (dataframe)  : a dataframe which has a rev-minus-expense column.
    #- xvar (factor)   : a variable to compare the rev-minus-expense column, most likely fiscal_year
    #- yvar (numeric)  : rev-minus-expense column most likely
    #- fillvar (factor): a category to fill the bars. 
    
  #Outputs:
    #-ggplot object: a plot 
    
  #Descrition:
    #make a barplot of revenues minus expenditures. I use the xvar to be fiscal year, the yvar to be the rev_minus_exp variable, and the fillvar to the sord category. 
  
  xvar <- enquo(xvar)
  yvar <- enquo(yvar)
  fillvar <- enquo(fillvar)
  
  df %>%
    ggplot(aes_(x = xvar,
                y = yvar,
                fill = fillvar)) +
    geom_bar(stat = "identity") +
    ylab( yvar %>% quo_name() %>% str_replace_all("_"," ") %>% str_to_title() )+
    xlab( xvar %>% quo_name() %>% str_replace_all("_"," ") %>% str_to_title() )+
    scale_y_continuous(labels = scales::dollar_format(prefix="$", big.mark =","))+
    scale_fill_manual(values=c("#E9707E", "#78CC62"), 
                       name="Surplus or\nDeficit Cat.",
                       breaks=c("deficit", "surplus"),
                       labels=c("deficit", "surplus"))
    
    
  #   scale_fill_manual(breaks = c("deficit","surplus"),
  #                     name = c("deficit", "surplus"),
  #                     values=c("#E9707E", "#78CC62")) # 517A9D and # 517A9D
  # # There is a minor bug I do not care enough to worry about fixing which is that if there is only one color, it deafults to the red "deficit color"
  
}
```

### pull_transaction_report_cleaned
```{r}

pull_transaction_report_cleaned <- function(entity_name, report_df) {
  
  #pluck transaction_data and clean it -----------------------------------------
  tr_df <- report_df %>%
    filter(name == entity_name) %>%
    pluck("queried_transactions", 1 , "transaction_report") %>%
    clean_transaction_report()
  
  #get perc of valid transactions
  perc_valid <- find_perc_of_valid_transactions(entity_name,report_df)
  
  dollar_valid<- find_dollar_of_valid_transactions(entity_name, report_df)
  
  
  #get the rev-exp stats
  yearly_stats <-
    tr_df %>% compute_rev_exp_stats(fiscal_year) #%>% arrange(fund)
  
  # calculate cagrs
  cagrs <- yearly_stats %>% calculate_CAGRs()
  
  # yearly plots 
  yearly_rme_plot <- rev_minus_exp_barplot(df = yearly_stats,
                        xvar = fiscal_year, 
                        yvar = rev_minus_exp,
                        fillvar = sord)
  # yearly plots 
  yearly_diff_rme_plot <- rev_minus_exp_barplot(df = yearly_stats,
                        xvar = fiscal_year, 
                        yvar = yearly_diff_rme,
                        fillvar = sord)
  
  
  outliers <-  check_outliers_year(yearly_stats)
  
  list(
    tr_df = tr_df,
    perc_valid = perc_valid,
    dollar_valid = dollar_valid,
    yearly_stats = yearly_stats,
    cagrs = cagrs,
    yearly_rme_plot = yearly_rme_plot,
    yearly_diff_rme_plot = yearly_diff_rme_plot,
    outliers =outliers
  )
  

}

```

```{r}
check_outliers_year <- function(agg_df){
  # I want to check for outlier years
  
  #perc_of_total_outlier
  outlier_perc_of_total <-
    agg_df %>% filter(perc_of_total >= 0.05) %>% select(fiscal_year, perc_of_total)
  #perc_of_type_outlier
  outlier_perc_of_type <-
    agg_df %>% filter(perc_of_type >= 0.10) %>% select(fiscal_year, perc_of_type)
  
  
  outlier_rev_minus_exp_vect <-
    boxplot.stats(agg_df$rev_minus_exp)$out
  
  outlier_rme <- agg_df %>%
    filter(perc_of_type %in%  outlier_rev_minus_exp_vect) %>%
    select(fiscal_year, perc_of_type)
  
  list(outlier_perc_of_total=outlier_perc_of_total,
       outlier_perc_of_type=outlier_perc_of_type,
       outlier_rme=outlier_rme)
  
  
}
```

```{r}
check_missing_fund <- function(){
  # I want to check for a missing fund that was present the previous year, and 
}
```

```{r}
check_outlier_fund <- function(){
  # I want to check for a missing fund that was present the previous year, and 
}
```

## execute
```{r}
report_names <- report %>% pull(name)

cleaned_reports <- report_names %>% map(pull_transaction_report_cleaned,report)

# cleaned_reports 

rm(report_names)
```


```{r}
report_names <- report %>% pull(name)

cleaned_reports <- report_names %>% map(pull_transaction_report_cleaned,report) %>% enframe()
cleaned_reports$name <- report_names
#cleaned_reports %>% rename(dqi_stats = value)
# cleaned_reports 

```


```{r}
total_data <- tibble()

for (temp_name in report_names) {
  temp_agg <-
    cleaned_reports %>%
    filter(name == temp_name) %>%
    pull(value) %>% 
    pluck(1, "yearly_stats") %>%
    mutate(entity_name = as.factor(temp_name))
  
  # temp_agg$name <- temp_name %>% as.character()
  
  total_data <- total_data %>% rbind(temp_agg)
}
```



```{r}

pp<- ggplot(total_data, aes(x = as.numeric(levels(fiscal_year))[fiscal_year],
                       y = rev_minus_exp, color = entity_name)) +
  geom_point() +
  geom_line()+
  ylab( "Fiscal Year" )+
  xlab( "Difference of Revenue and Expenditure" )
```

```{r}
library(plotly)
```


```{r}
pp <- ggplotly(pp)
```

