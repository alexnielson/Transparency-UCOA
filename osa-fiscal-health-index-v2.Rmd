---
title: "osa-fiscal-health-index-v2"
author: "Alexander Nielson"
date: "3/12/2020"
output: html_document
---

Program Description:

**Purpose**

**Input(s)**

```{r}
dsn_aws        <- "transpAWS"
dsn_salesforce <- "salesforce"
```

**Output(s)**

# LIB AND DATA SOURCE

```{r}
options(scipen=6)

library(lubridate)
library(magrittr)
library(odbc)
library(readxl) 
library(tidyverse)
library(stringi) 
library(tidyr)
library(plotly)

odbc_aws <- dbConnect(odbc::odbc(), dsn_aws)
odbc_sf  <- dbConnect(odbc::odbc(), dsn_salesforce)

rm(dsn_aws, dsn_salesforce)
```



# FUNCTION DEFINITIONS

## Validation functions

# II. Function Definitions

## a. database validation
### validate_nrow

```{r}
validate_nrow <- function(df, expected_nrow) {
  # Verify the number of rows in a data frame rounds to the expected value.
  #
  # Arguments:
  #   df (tbl): The data frame to validate.
  #   expected_nrow (num): The number of rows the report should contain, rounded
  #     to one significant digit.
  #
  # Value:
  #   Nothing, or a `stop()` message.
  
  if (!identical(df%>%nrow()%>%signif(1),
                 expected_nrow)) {
    
    paste0("The rounded number of rows in ", 
           deparse(substitute(df)),
           " is not near the expected ", 
           expected_nrow, 
           ". Did the data frame import correctly? 
           Did the number of entities we monitor change significantly?") %>% 
      stop()
  }
}
```

### make_current_begin_fy

```{r}
make_current_begin_fy <- function(begin_fy_unchecked) {
  # Update an outdated fiscal year begin date.
  #
  # Arguments:
  #   begin_fy_unchecked (Date): The first day of the entity's fiscal year, not
  #     yet verified to reflect the current fiscal year.
  #
  # Value:
  #   Date.
  #
  # Comments:
  #   As of 2019-03, our instance of Salesforce does not reliably update the
  #   Fiscal_Year_Begins__c field. Coding the update in this program was a
  #   quicker solution than waiting for the problem to be fixed in Salesforce.
  
  !(begin_fy_unchecked > today()) || 
    
    stop("make_current_begin_fy() must not be applied to future dates.",
         call. = FALSE)
  
  fy_interval <- 
    begin_fy_unchecked %--% ((begin_fy_unchecked + years(1)) - 1)
  
  if (today() %within% fy_interval) {
    
    begin_fy_unchecked
    
  } else {
    
    year_correction <- 
      (year(today()) - year(begin_fy_unchecked)) %>% 
      if_else(
        month(begin_fy_unchecked) != 1 &
          month(begin_fy_unchecked) > month(today()),
        . - 1,
        .)
    
    begin_fy_unchecked + months(12 * year_correction)
  }
}
```

### query_batch_ids

```{r}
query_batch_ids <- function(t_id) {
  # Query an entity's processed and processing batch IDs.
  #
  # Arguments:
  #   t_id (num): The entity's Transparency ID, as queried from Salesforce
  #     rather than Transparency.
  #
  # Value:
  #   Numeric.
  #
  # Comments:
  #   The 'DONTDELETE' batch status is a variation of 'PROCESSED.' DONTDELETE 
  #   indicates the data in the batch has been split among multiple transaction
  #   tables, as the batch contains data from a fiscal year that has been 
  #   archived.
  
  if (is.na(t_id)) {
    
    return(vector(mode = "numeric", length = 0)) 
  }
  
  dbGetQuery(
    odbc_aws,
    paste("
          SELECT id
          FROM batch
          WHERE entity_id = ", t_id, "
          AND status IN ('PROCESSED', 'PROCESSING', 'DONTDELETE')")) %>% 
    .[["id"]] %>%
    as.numeric()
}
```
## b. UCA related
###  query_and_validate_transactions
```{r}
query_and_validate_transactions <- function(batches_list, lookup_table) {
  # Query an entity's batches, and validate the the transactions.
  #
  # Arguments:
  #   t_id (num): The entity's Transparency ID, as queried from Salesforce
  #     rather than Transparency.
  #
  # Value:
  #   Numeric.
  #
  # Comments:
  #   The 'DONTDELETE' batch status is a variation of 'PROCESSED.' DONTDELETE 
  #   indicates the data in the batch has been split among multiple transaction
  #   tables, as the batch contains data from a fiscal year that has been 
  #   archived.
  
  
  batches_wrangled <- batches_list %>%
    unlist() %>%
    as.character() %>%
    str_split(" ") %>%
    unlist() %>%
    #sQuote() %>%
    paste(collapse = ", ")
  
  
  # 1. Query the database, get all the records -----------------------------------
  
  transaction_report <-
    dbGetQuery(
      odbc_aws,
      paste(
        "
      SELECT id,
      batch_id,
      amount,
      fiscal_year,
      account_number,
      type
      FROM transaction
      WHERE (type = 1 OR type = 2)
      AND batch_id IN (",
      batches_wrangled,
      ")"
      
      )
    ) %>%
    as_tibble()
  
  # bsafeguard against "invalid mutlibyte string, element 372860" error
  transaction_report$account_number  <- iconv(transaction_report$account_number ,"WINDOWS-1252","UTF-8")
  
  # 2. check for NA or "" ------------------------------------------------------
  
  invalid_reported_na <- transaction_report %>%
    filter(account_number == "",
           is.na(account_number))
  
  transaction_report <- transaction_report %>%
    filter(account_number != "",
           !is.na(account_number))
  
  # 3. check correct length ----------------------------------------------------
  #Note: 19 is for OSA, 25 is for USBE (dashes are included in string legth)
  invalid_length <- transaction_report %>%
    filter(stri_length(account_number) != 19) %>%
    mutate(
      account_number_length = nchar(account_number),
      reason = case_when(
        account_number_length < 19 ~ paste("Invalid Length - Code block too short - length =", account_number_length),
        account_number_length > 19 ~ paste("Invalid Length - Code block too long  - length =", account_number_length)
      )
    )
  
  transaction_report <- transaction_report %>%
    filter(stri_length(account_number) == 19)
  
  # 4. check for valid form. ie: ##-###-####-####-###-#### ---------------------
  
  invalid_form <-
    transaction_report %>%
    filter(!str_detect(
      .$account_number,
      regex("^[:digit:]{3}-[:digit:]{6}-[:digit:]{8}$")
    )) %>% 
    mutate(
      reason = "Invalid Form - form must be : ###-######-########"
    )
  
  # transaction_report <-
  #   transaction_report %>%
  #   filter(str_detect(
  #     .$account_number,
  #     regex("^[:digit:]{3}-[:digit:]{6}-[:digit:]{8}$")
  #   ))
  # 
  # I think an anti-join will be faster than filter
  
  transaction_report <- transaction_report %>% 
    anti_join(invalid_form, by = "id")
  
  #5. enrich the transaction_report --------------------------------------------
  
  transaction_report <- transaction_report %>%
    mutate(
      fund                    = .[["account_number"]] %>% substr(0, 3),
      funct                   = .[["account_number"]] %>% substr(5, 10),
      account                 = .[["account_number"]] %>%  substr(12, 19),
      fund_code_primary       = str_sub(fund, 0, 2),
      fund_code_secondary     = str_sub(fund, 2, 3),
      funct_code_primary      = str_sub(funct, 0, 2),
      funct_code_secondary    = str_sub(funct, 3, 4),
      funct_code_tertiary     = str_sub(funct, 5, 6),
      account_code_primary    = str_sub(account, 0, 2),
      account_code_secondary  = str_sub(account, 3, 4),
      account_code_tertiary   = str_sub(account, 5, 6),
      account_code_quaternary = str_sub(account, 7, 8)
    ) %>%
    
    # Now we need to join ucoa.xlsx, so we know what the codes mean.
    
    # join the funds
    left_join(
      lookup_table %>%
        pluck("fund") %>%
        as_tibble() %>%
        select(
          number,
          fund_description = description,
          fund_level_primary = level_primary,
          fund_level_secondary = level_secondary
        ),
      by = c("fund" = "number")
    ) %>%
    # join the functions
    left_join(
      lookup_table %>%
        pluck("funct") %>%
        as_tibble() %>%
        select(
          number,
          funct_description = description,
          funct_level_primary = level_primary,
          funct_level_secondary = level_secondary,
          funct_level_tertiary = level_tertiary
        ),
      by = c("funct" = "number")
    ) %>%
    # join the accounts
    left_join(
      lookup_table %>%
        pluck("account") %>%
        as_tibble() %>%
        select(
          number,
          account_description = description,
          account_level_primary = level_primary,
          account_level_secondary = level_secondary,
          account_level_tertiary = level_tertiary
        ),
      by = c("account" = "number")
    )
  
  #6. Filter out any non revenue and expense uca -------------------------------
  
  # stimexp <- transaction_report %>%
  #   filter(type == 4) %>%
  #   mutate(type=type,
  #          transaction_type = "stimulus expense",
  #          reason = "Invalid Transaction Type - transaction type correpsonds to stimulus expense(must be a Revenue or Expense).")
  # 
  # stimrev <- transaction_report %>%
  #   filter(type == 5) %>%
  #   mutate(type=type,
  #          transaction_type = "stimulus revenue",
  #          reason = "Invalid Transaction Type - transaction type correpsonds to stimulus revenue(must be a Revenue or Expense).")
  # 
  # budget <- transaction_report %>%
  #   filter(type == 6) %>%
  #   mutate(type=type,
  #          transaction_type = "budget",
  #          reason = "Invalid Transaction Type - transaction type correpsonds to budget (must be a Revenue or Expense).")
  # 
  # balance_sheet <- transaction_report %>%
  #   filter(type == 7) %>%
  #   mutate(type=type,
  #          transaction_type = "balance sheet",
  #          reason = "Invalid Transaction Type - transaction type correpsonds to balance sheet (must be a Revenue or Expense).")
  # 
  # invalid_transaction_type <- stimexp %>%
  #   bind_rows(stimrev) %>%
  #   bind_rows(budget) %>%
  #   bind_rows(balance_sheet)
  # 
  # transaction_report<- transaction_report %>%
  #    anti_join(stimexp, by="id")%>%
  #    anti_join(stimrev, by="id")%>%
  #    anti_join(budget, by="id")%>%
  #    anti_join(balance_sheet, by="id")

  #get all the accounts that start with a 1 or a 2. These are not acceptable uca according to Darell. 
  # rev_begin_with1 <- transaction_report %>%
  #   filter(type == 2 && str_sub(account, 0, 1) == 1) %>%
  #   mutate(reason = "Invalid Account block - account block starts with 1 - Account chunk must start with a 3 (revenue) or 4 (expenditure).")
  # 
  # exp_begin_with1 <- transaction_report %>%
  #   filter(type == 1 && str_sub(account, 0, 1) == 1) %>%
  #   mutate(reason = "Invalid Account block - account block starts with 1 - Account chunk must start with a 3 (revenue) or 4 (expenditure).")
  # 
  # rev_begin_with2 <- transaction_report %>%
  #   filter(type == 2 && str_sub(account, 0, 1) == 2) %>%
  #   mutate(reason = "Invalid Account block - account block starts with 2 - Account chunk must start with a 3 (revenue) or 4 (expenditure).")
  # 
  # exp_begin_with2 <- transaction_report %>%
  #   filter(type == 1 && str_sub(account, 0, 1) == 2) %>%
  #   mutate(reason = "Invalid Account block - account block starts with 2 - Account chunk must start with a 3 (revenue) or 4 (expenditure).")

  # invalid_account_type <- rev_begin_with1 %>%
  #   bind_rows(exp_begin_with1)%>%
  #   bind_rows(rev_begin_with2)%>%
  #   bind_rows(exp_begin_with2)
  #   
  
  # invalid_account_type <- transaction_report %>%
  #   filter((type == 1 || type ==2) && (str_sub(account, 0, 1) == 1 ||str_sub(account, 0, 1) == 2)) %>%
  #   mutate(reason = "Invalid Account block - Account chunk must start with a 3 (revenue) or 4 (expenditure).")
  
  invalid_account_type <- transaction_report %>%
    # filter((str_sub(account, 0, 1) == 1  & type == 1) |
    #          (str_sub(account, 0, 1) == 1  & type == 2) |
    #          (str_sub(account, 0, 1) == 2  & type == 1) |
    #          (str_sub(account, 0, 1) == 2  & type == 1)
    # ) %>%
    filter((str_sub(account, 0, 1) == 1) |
             (str_sub(account, 0, 1) == 1) |
             (str_sub(account, 0, 1) == 2) |
             (str_sub(account, 0, 1) == 2)) %>% 
    mutate(reason = "Invalid Account Chunk - Account chunk must start with a 3 (revenue) or 4 (expenditure).")

  transaction_report<- transaction_report %>%
     anti_join(invalid_account_type, by="id")
  
  
  #7. Find unmapped uca codes --------------------------------------------------
  
  #find wrong fund code
  unmapped_fund_code <- transaction_report %>%
    filter(!fund %in% (lookup_table %>%
                         pluck("fund")  %>%
                         select(number) %>%
                         unlist())) %>%
    select(
      id,
      batch_id,
      amount,
      type,
      fiscal_year,
      account_number,
      fund,
      fund_code_primary,
      fund_code_secondary
    ) %>% 
    mutate(
      reason = "Invalid Fund Code - The fund code does not exist in the current uniform chart of accounts. "
    )
  
  #If the fund code does not map, we want to know which component of the code
  #failed. ie: was it the primary or secondary component?
  
  # check primary
  unmapped_fund_code_primary <- unmapped_fund_code %>%
    filter(!fund_code_primary %in% (
      lookup_table %>%
        pluck("fund")  %>%
        select(code_primary) %>%
        unlist()
    ))%>% 
    mutate(
      reason = "Invalid Fund Code - The primary piece of the fund code does not exist in the current uniform chart of accounts. "
    )
  
  #check secondary
  unmapped_fund_code_primary <- unmapped_fund_code %>%
    filter(!fund_code_primary %in% (
      lookup_table %>%
        pluck("fund")  %>%
        select(code_primary) %>%
        unlist()
    )) %>% 
    mutate(
      reason = "Invalid Fund Code - The secondary piece the fund code does not exist in the current uniform chart of accounts. "
    )
  
  
  #find wrong function code
  unmapped_funct_code <- transaction_report %>%
    filter(!funct %in% (
      lookup_table %>%
        pluck("funct") %>%
        select(number) %>%
        unlist()
    )) %>%
    select(
      id,
      batch_id,
      amount,
      type,
      fiscal_year,
      account_number,
      funct,
      funct_code_primary,
      funct_code_secondary,
      funct_code_tertiary
    ) %>%
    mutate(reason = "Invalid Function Code - The function code does not exist in the current uniform chart of accounts. ")
  
  #If the funct code does not map, we want to know which component of the code
  #failed. ie: was it the primary, secondary, or tertiary component?
  
  #check funct primary
  unmapped_funct_code_primary <- unmapped_funct_code %>%
    filter(!funct_code_primary %in% (
      lookup_table %>%
        pluck("funct")  %>%
        select(code_primary) %>%
        unlist()
    )) %>%
    mutate(reason = "Invalid Function Code - The first and/or second digits of the function code do not exist in the current uniform chart of accounts. ")
  
  
  #check funct secondary
  unmapped_funct_code_secondary <- unmapped_funct_code %>%
    filter(
      funct_code_primary %in% (
        lookup_table %>%
          pluck("funct")  %>%
          select(code_primary) %>%
          unlist()
      )
      ,
      !funct_code_secondary %in% (
        lookup_table %>%
          pluck("funct")  %>%
          select(code_secondary) %>%
          unlist()
      )
    ) %>%
    mutate(reason = "Invalid Function Code - The third and/or fourth digits of the function code do not exist in the current uniform chart of accounts. ")
  
  
  # check funct tertiary
  unmapped_funct_code_tertiary <- unmapped_funct_code %>%
    filter(
      funct_code_primary %in% (
        lookup_table %>%
          pluck("funct")  %>%
          select(code_primary) %>%
          unlist()
      )
      ,
      funct_code_secondary %in% (
        lookup_table %>%
          pluck("funct")  %>%
          select(code_secondary) %>%
          unlist()
      )
      ,
      !funct_code_tertiary %in% (
        lookup_table %>%
          pluck("funct")  %>%
          select(code_tertiary) %>%
          unlist()
      )
    ) %>%
    mutate(reason = "Invalid Function Code - The fifth and/or sixth digits of the function code do not exist in the current uniform chart of accounts. ")
  
  # check account
  unmapped_account_code <- transaction_report %>%
    filter(!account %in% (
      lookup_table %>%
        pluck("account") %>%
        select(number)   %>%
        unlist()
    )) %>%
    select(
      id,
      batch_id,
      amount,
      type,
      fiscal_year,
      account_number,
      account,
      account_code_primary,
      account_code_secondary,
      account_code_tertiary,
      account_code_quaternary
    )%>%
    mutate(reason = "Invalid Account Code - The account code does not exist in the current uniform chart of accounts. ")
  
  #If the funct code does not map, we want to know which component of the code
  #failed. ie: was it the primary, secondary, tertiary, quaternary component?
  
  #check account primary
  unmapped_account_code_primary <- unmapped_account_code %>%
    filter(!account_code_primary %in% (
      lookup_table %>%
        pluck("account")  %>%
        select(code_primary) %>%
        unlist()
    )) %>% 
    mutate(reason = "Invalid Account Code - The first and/or second digits of account code do not exist in the current uniform chart of accounts. ")
  
  
  #check account secondary
  unmapped_account_code_secondary <- unmapped_account_code %>%
    filter(
      account_code_primary %in% (
        lookup_table %>%
          pluck("account")  %>%
          select(code_primary) %>%
          unlist()
      ),
      !account_code_secondary %in% (
        lookup_table %>%
          pluck("account")  %>%
          select(code_secondary) %>%
          unlist()
      )
    )%>%
    mutate(reason = "Invalid Account Code - The third and/or fourth digits of the account code do not exist in the current uniform chart of accounts. ")
  
  
  unmapped_account_code_tertiary <- unmapped_account_code %>%
    filter(
      account_code_primary %in% (
        lookup_table %>%
          pluck("account")  %>%
          select(code_primary) %>%
          unlist()
      ),
      account_code_secondary %in% (
        lookup_table %>%
          pluck("account")  %>%
          select(code_secondary) %>%
          unlist()
      ),
      !account_code_tertiary %in% (
        lookup_table %>%
          pluck("account")  %>%
          select(code_tertiary) %>%
          unlist()
      )
    )%>%
    mutate(reason = "Invalid Account Code - The fifth and/or sixth digits of the account code do not exist in the current uniform chart of accounts. ")
  
  unmapped_account_code_quaternary <- unmapped_account_code %>%
    filter(
      account_code_primary %in% (
        lookup_table %>%
          pluck("account")  %>%
          select(code_primary) %>%
          unlist()
      ),
      account_code_secondary %in% (
        lookup_table %>%
          pluck("account")  %>%
          select(code_secondary) %>%
          unlist()
      ),
      account_code_tertiary %in% (
        lookup_table %>%
          pluck("account")  %>%
          select(code_tertiary) %>%
          unlist()
      )#,
      # !account_code_quaternary %in% (
      #   lookup_table %>%
      #     pluck("account")  %>%
      #     select(code_quaternary) %>%
      #     unlist()
      # )
    )%>%
    mutate(reason = "Invalid Account Code - The seventh and/or eighth digits of the account code do not exist in the current uniform chart of accounts. ")
  
  #now remove incorrectly mapped. we will save them to report, but do not want
  #them in our analysis.
  transaction_report <- transaction_report %>%
    anti_join(unmapped_fund_code, by = "id") %>%
    anti_join(unmapped_funct_code, by = "id") %>%
    anti_join(unmapped_account_code, by = "id")
  
  #8. check account type -------------------------------------------------------
  
  # finally check that the account is mapped to the transaction type 
  # 1 = expediture
  # 2 = revenue
  
  exp_transaction_but_rev_account <- transaction_report %>%
    filter(type == 1 & str_sub(account, 0, 1) == 3)%>%
    mutate(reason = "Invalid Account Code or Transaction Type - the transaction is listed as an expenditure, but has an account code correpsonding to a revenue ") %>% 
    select(
      id,
      batch_id,
      amount,
      type,
      fiscal_year,
      account_number,
      account,
      reason
    )

  rev_transaction_but_exp_account <- transaction_report %>%
    filter(type == 2 & str_sub(account, 0, 1) == 4)%>%
    mutate(reason = "Invalid Account Code or Transaction Type - the transaction is listed as a revenue, but has an account code correpsonding to a expenditure ") %>%
    select(
      id,
      batch_id,
      amount,
      type,
      fiscal_year,
      account_number,
      account,
      reason
    )
  
  transaction_report <- transaction_report %>% 
    anti_join(exp_transaction_but_rev_account, by = "id") %>% 
    anti_join(rev_transaction_but_exp_account, by = "id")
  

  # Deal with NOT Applicable Function Code. We need to filter these out now. 
  
  rev_invalid_function_use <- transaction_report %>%
    filter( type == 2 & funct == "000000") %>%
    mutate(reason = "Invalid Function Code - The 'Not Applicable' function code (000000) is no longer acceptable. Fix by listing an appropriate function code.")
  
  
  exp_invalid_function_use <- transaction_report %>%
    filter(type == 1  & funct == "000000") %>%
    mutate(reason = "Invalid Function Code - The 'Not Applicable' function code (000000) is no longer acceptable. Fix by listing an appropriate function code.")
  
  invalid_function_use <- rev_invalid_function_use %>% bind_rows(exp_invalid_function_use)
  
  transaction_report<- transaction_report %>% 
    anti_join(invalid_function_use, by="id")
  

  #now create a tibble which can let us know if there are errors present.
  if(transaction_report %>% nrow()==0){no_transactions = TRUE }else{no_transactions= FALSE}
  if(invalid_reported_na %>% nrow()>0){fail_na = TRUE }else{fail_na= FALSE}
  if(invalid_length %>% nrow()>0){fail_length = TRUE }else{fail_length = FALSE}
  if(invalid_form %>% nrow()>0){fail_form = TRUE }else{fail_form =FALSE}
#  if(invalid_transaction_type %>% nrow()>0){fail_transaction_type = TRUE }else{fail_transaction_type =FALSE}
  if(invalid_account_type %>% nrow()>0){fail_account_type = TRUE }else{fail_account_type =FALSE}
  if(unmapped_fund_code %>% nrow()>0){fail_fund = TRUE }else{fail_fund = FALSE}
  if(unmapped_funct_code %>% nrow()>0){fail_funct = TRUE }else{fail_funct =FALSE}
  if(unmapped_funct_code_primary %>% nrow()>0){fail_funct_pri = TRUE }else{fail_funct_pri =FALSE}
  if(unmapped_funct_code_secondary %>% nrow()>0){fail_funct_sec = TRUE }else{fail_funct_sec =FALSE}
  if(unmapped_funct_code_tertiary %>% nrow()>0){fail_funct_ter = TRUE }else{fail_funct_ter =FALSE}
  if(unmapped_account_code %>% nrow()>0){fail_account = TRUE }else{fail_account = FALSE}
  if(unmapped_account_code_primary %>% nrow()>0){fail_account_pri = TRUE }else{fail_account_pri =FALSE}
  if(unmapped_account_code_secondary %>% nrow()>0){fail_account_sec = TRUE }else{fail_account_sec =FALSE}
  if(unmapped_account_code_tertiary %>% nrow()>0){fail_account_ter = TRUE }else{fail_account_ter =FALSE}
  if(unmapped_account_code_quaternary %>% nrow()>0){fail_account_qua = TRUE }else{fail_account_qua = FALSE}
  if(exp_transaction_but_rev_account %>% nrow()>0){fail_exp_as_rev = TRUE }else{fail_exp_as_rev =FALSE}
  if(rev_transaction_but_exp_account %>% nrow()>0){fail_rev_as_exp = TRUE }else{fail_rev_as_exp =FALSE}
  if(invalid_function_use %>% nrow()>0){fail_na_function_use = TRUE }else{fail_na_function_use =FALSE}

  summary_tibble <- tibble(

    name = c(
      "transaction_report",
      "invalid_reported_na",
      "invalid_length",
      "invalid_form",
#      "fail_transaction_type",
      "fail_account_type",
      "unmapped_fund_code",
      "unmapped_funct_code",
      "unmapped_funct_code_primary",
      "unmapped_funct_code_secondary",
      "unmapped_funct_code_tertiary",
      "unmapped_account_code",
      "unmapped_account_code_primary",
      "unmapped_account_code_secondary",
      "unmapped_account_code_tertiary",
      "unmapped_account_code_quaternary",
      "exp_transaction_but_rev_account",
      "rev_transaction_but_exp_account",
      "fail_na_function_use"
    ),

    status = c(
      no_transactions,
      fail_na,
      fail_length,
      fail_form,
#      fail_transaction_type,
      fail_account_type,
      fail_fund,
      fail_funct,
      fail_funct_pri,
      fail_funct_sec,
      fail_funct_ter,
      fail_account,
      fail_account_pri,
      fail_account_sec,
      fail_account_ter,
      fail_account_qua,
      fail_exp_as_rev,
      fail_rev_as_exp,
      fail_na_function_use
    )

  )
  
  
  
  # consolidate ----------------------------------------------------------------
  entity_info <-
    list(
      "transaction_report" = transaction_report,                            #1
      "invalid_reported_na" = invalid_reported_na,                          #2  
      "invalid_length" = invalid_length,                                    #3 
      "invalid_form" = invalid_form,                                        #4
      "unmapped_fund_code" = unmapped_fund_code,                            #5 
      "unmapped_funct_code" = unmapped_funct_code,                          #6 
      "unmapped_funct_code_primary" = unmapped_funct_code_primary,          #7
      "unmapped_funct_code_secondary" = unmapped_funct_code_secondary,      #8
      "unmapped_funct_code_tertiary" = unmapped_funct_code_tertiary,        #9
      "unmapped_account_code" = unmapped_account_code,                      #10
      "unmapped_account_code_primary" = unmapped_account_code_primary,      #11
      "unmapped_account_code_secondary" = unmapped_account_code_secondary,  #12
      "unmapped_account_code_tertiary" = unmapped_account_code_tertiary,    #13
      "unmapped_account_code_quaternary" = unmapped_account_code_quaternary,#14
      "exp_transaction_but_rev_account" = exp_transaction_but_rev_account,  #15
      "rev_transaction_but_exp_account" = rev_transaction_but_exp_account,
#      "invalid_transaction_type" = invalid_transaction_type,
      "invalid_account_type" = invalid_account_type,
      "invalid_function_use" = invalid_function_use,
      "summary_tibble" = summary_tibble
      
    ) #%>% enframe()
}

```

### extract_summary_tibble
```{r}
extract_summary_tibble <- function(entity_name, report_df){
  report_df <- report_df %>% 
    filter(name == entity_name) %>% 
    pull(queried_transactions) %>% 
    pluck(1) %>% 
    pluck("summary_tibble")
  
}
```

### extract_summary_tibble_errors
```{r}
extract_summary_tibble_errors <- function(entity_name, report_df){
    report_df <- report_df %>% 
    filter(name == entity_name)
  
  if(report_df %>% 
    pull(queried_transactions) %>% 
    pluck(1) %>% 
    pluck("summary_tibble") %>% 
    filter(status=="TRUE") %>% 
    nrow() > 0){
    wrong_types <- report_df %>%
      pull(queried_transactions) %>%
      pluck(1) %>%
      pluck("summary_tibble") %>%
      filter(status == "TRUE") %>%
      pull(name) %>% 
      paste(., collapse = ', ')
  }else{
      wrong_types <- paste("no_errors")
    }
  
}
```

### pluck_queried_transactions
```{r}
pluck_queried_transactions <- function(entity_name, report_df){
      report_df %>% 
      filter(name==entity_name) %>%
      pull(queried_transactions) %>%
      pluck(1) 
}
```

### standard_export_form

```{r}
standard_export_form <- function(report_df){
  report_df %>%  mutate(
      transaction_type = case_when(
        type == 1 ~ "expenditure",
        type == 2 ~ "revenue",
        type == 3 ~ "employee compensation",
        type == 4 ~ "stimulus expense",
        type == 5 ~ "stimulus revenue",
        type == 6 ~ "budget",
        type == 7 ~ "balance sheet"
      )
    ) %>%
    select(
      fiscal_year,
      batch_id,
      "transaction_id" = id,
      amount,
      type,
      transaction_type,
      account_number,
      #account_number_length,
      reason,
    )
}
```

## c. FHI functions

### compare_rev_exp
```{r}
compare_rev_exp<- function(df, ...){
  # Purpose: groups the data by supplied grouping variables, and aggregates the
  # date to have a total dollar amount and a count for the number of transactions
  # with such variables. Basically this will group uca codings into dollar and
  # frequency amounts. Two metrics of interest to Alex.
  #
  # Inputs: *df (tibble or dataframe): a dataframe which has the grouping variables. it should have an amount column
  #         *... : the grouping variables. should be a uca field.
  # Outputs: tibble :an aggregated tibble
  
  grouping_vars <- enquos(...)
  
  revenues <- df %>%
    filter(type == 2) %>%
    group_by(!!!grouping_vars) %>%
    summarize(rev_total_amount = sum(amount),
              rev_num_of_trans = n()) %>%
    mutate(rev_total_amount = rev_total_amount) 
  
  expenditures <- df %>%
    filter(type == 1) %>%
    group_by(!!!grouping_vars) %>%
    summarize(exp_total_amount = sum(amount),
              exp_num_of_trans = n()) %>%
    mutate(exp_total_amount = exp_total_amount)
    
  
  difference <- revenues %>% full_join(expenditures,) %>%
    mutate_each(~ replace(., which(is.na(.)), 0))
  
  difference <- difference %>%
    mutate(
      rev_minus_exp = abs(rev_total_amount) - abs(exp_total_amount),
      avg = mean(rev_minus_exp),
      sd = sd(rev_minus_exp),
      sd = case_when(is.na(sd) ~ 0,
                     TRUE ~ sd)
    ) %>%
    mutate(sord_category = case_when(
      rev_minus_exp >= 0 ~ "surplus",
                                rev_minus_exp <  0 ~ "deficit"),
           
           avg_category = case_when (
             rev_minus_exp > avg + sd ~ "above average",
             rev_minus_exp < avg - sd ~ "below average",
             TRUE ~ "average"
           )
           ) %>%
   # mutate(fiscal_year = factor(fiscal_year)) %>% 
    arrange(desc(fiscal_year, exp_total_amount))
}
```
### Fund Analysis

#### plot_fund_by_year
```{r}

plot_fund_by_year <- function(fiscal_years,entity_name, df) {
  fiscal_years <- enquo(fiscal_years)
  df <- df %>% filter(fiscal_year == !!fiscal_years)
  
  ggplot(data = df,
         aes(x = fund_descr_code,
             y = rev_minus_exp,
             fill = sord_category)) +
    geom_bar(stat = "identity") +
    coord_flip() +
    geom_text(
      aes(label = paste(
        "$", format(rev_minus_exp, big.mark = ",", trim = TRUE)
      )),
      color = "black",
      fontface = "bold",
      #vjust = 'inward',
      hjust = "inward",
      size = 4,
      alpha = .5
    ) +
    labs(
      title = paste("Fund- Fiscal Health Analysis - Fiscal Year: ", as_label(fiscal_years)),
      subtitle = paste(entity_name)
    ) +
    scale_fill_manual(
      values = c(
        "surplus" = "#7CAE00",
        "deficit" = "#F8766D"
      )
    ) +
        xlab("Fiscal Year") +
      ylab("Difference of Revenues and Expenditures")
  
}
```

### Funct Analysis



#### plot_funct_by_year
```{r}


plot_funct_by_year <- function(fiscal_years, entity_name, df) {
  fiscal_years <- enquo(fiscal_years)
  df <- df %>% filter(fiscal_year == !!fiscal_years)
  
  ggplot(data = df,
         aes(x = funct_descr_code,
             y = rev_minus_exp,
             fill = sord_category)) +
    geom_bar(stat = "identity") +
    coord_flip() +
    geom_text(
      aes(label = paste(
        "$", format(rev_minus_exp, big.mark = ",", trim = TRUE)
      )),
      color = "black",
      fontface = "bold",
      #vjust = 'inward',
      hjust = "inward",
      size = 4,
      alpha = .5
    ) +
    labs(
      title = paste(
        "Function- Fiscal Health Analysis - Fiscal Year: ",
        as_label(fiscal_years)
      ),
      subtitle = paste(entity_name)
    ) +
    scale_fill_manual(values = c("surplus" = "#7CAE00",
                                 "deficit" = "#F8766D")) +
    xlab("Fiscal Year") +
    ylab("Difference of Revenues and Expenditures")
  
}
```

#### plot_net_amount_by_funct
```{r}
plot_net_amount_by_funct <-
  function(funct_numbers, entity_name, df) {
    funct_numbers <- enquo(funct_numbers)
    
    df <- df %>% filter(funct == !!funct_numbers)
    
    ggplot(data = df,
           aes(x = fiscal_year,
               y = rev_minus_exp,
               fill = avg_category)) +
      geom_bar(stat = "identity") +
      coord_flip() +
      geom_text(
        aes(label = paste(
          "$", format(rev_minus_exp, big.mark = ",", trim = TRUE)
        )),
        color = "black",
        fontface = "bold",
        #vjust = 'inward',
        hjust = "inward",
        size = 4,
        alpha = .5
      ) +
      labs(
        title = paste(
          "Funct-",
          # case_when(
          #   str_detect(account_numbers, "^0") ~ "Not Applicable",
          #   str_detect(account_numbers, "^0") ~ "General Government",
          #   str_detect(account_numbers, "^0") ~ "Not Applicable",
          #   str_detect(account_numbers, "^0") ~ "Not Applicable",
          # ),
          df$funct_description
        ),
        subtitle = paste(entity_name)
      ) +
      
      scale_fill_manual(
        values = c(
          
          "average" = "#00BFC4",
          "below average" = "#F8766D",
          "above average" = "#7CAE00"
          # #"average" = "#00BFC4",
          # "deficit" = "#F8766D",
          # "surplus" = "#7CAE00"
        )
      ) +
      ylab("Fiscal Year") +
      xlab("Net Amount ($)")
    
  }

```


###Account Analysis

#### agg_accounts
```{r}
agg_accounts <- function(df,trxn_type, ...) {
  # Purpose: groups the data by supplied grouping variables, and aggregates the
  # date to have a total dollar amount and a count for the number of transactions
  # with such variables. Basically this will group uca codings into dollar and
  # frequency amounts. Two metrics of interest to Alex.
  #
  # Inputs: *df (tibble or dataframe): a dataframe which has the grouping variables. it should have an amount column
  #         * trxn_type (a numeric): 1 == expense, 2==revenue, 3 == w2. meant to stand for Revenue OR Expense.
  #         *... : the grouping variables. should be a uca field.
  # Outputs: tibble :an aggregated tibble
  
  grouping_vars <- enquos(...)
  
  expenditures <- df %>%
    filter(type == trxn_type) %>%
    group_by(!!!grouping_vars) %>%
    summarize(total_amount = sum(amount),
              num_of_trans = n()) %>%
    mutate(avg = mean(total_amount),
           stdv = sd(total_amount)) %>%
    arrange(desc(fiscal_year, total_amount)) %>%
    mutate(
      fiscal_year = fct_explicit_na(fiscal_year),
      category = case_when(
        total_amount <= avg - stdv ~ 'below average',
        total_amount >= avg + stdv ~ 'above average',
        TRUE ~ 'average'
      )
    )
  
}
```






#### plot_account_by_year
```{r}
plot_account_by_year <- function(fiscal_years,entity_name, df) {
  fiscal_years <- enquo(fiscal_years)
  df <- df %>% filter(fiscal_year == !!fiscal_years)
  
  ggplot(data = df,
         aes(x = account_description,
             y = total_amount,
             fill = category)) +
    geom_bar(stat = "identity") +
    coord_flip() +
    geom_text(
      aes(label = paste(
        "$", format(total_amount, big.mark = ",", trim = TRUE)
      )),
      color = "black",
      fontface = "bold",
      #vjust = 'inward',
      hjust = "inward",
      size = 4,
      alpha = .5
    ) +
    labs(
      title = paste("Account - Fiscal Year: ", as_label(fiscal_years)),
      subtitle = paste(entity_name)
    ) +
    scale_fill_manual(
      values = c(
        "average" = "#00BFC4",
        "below average" = "#F8766D",
        "above average" = "#7CAE00"
      )
    ) +
          ylab("Fiscal Year") +
      xlab("Net Amount ($)")
  
}
```

#### plot_net_amount_by_account
```{r}
plot_net_amount_by_account <-
  function(account_numbers, entity_name, df) {
    fiscal_years <- enquo(account_numbers)
    df <- df %>% filter(account == !!account_numbers)
    
    ggplot(data = df,
           aes(x = fiscal_year,
               y = total_amount,
               fill = category)) +
      geom_bar(stat = "identity") +
      coord_flip() +
      geom_text(
        aes(label = paste(
          "$", format(total_amount, big.mark = ",", trim = TRUE)
        )),
        color = "black",
        fontface = "bold",
        #vjust = 'inward',
        hjust = "inward",
        size = 4,
        alpha = .5
      ) +
      labs(
        title = paste(
          "Account-",
          if_else(
            str_detect(account_numbers, "^4"),
            "Expenditure:",
            "Revenue:"
          ),
          df$account_description
        ),
        subtitle = paste(entity_name)
      ) +
      
      scale_fill_manual(
        values = c(
          "average" = "#00BFC4",
          "below average" = "#F8766D",
          "above average" = "#7CAE00"
        )
      ) +
      ylab("Fiscal Year") +
      xlab("Net Amount ($)")
    
  }

```

### Single entity Comparison
####entity_fiscal_health_data
```{r}
entity_fiscal_health_data <- function(entity_name , report_df){
  #Fund Analysis:
  print(paste("DEBUGG: starting entity_fiscal_health_data for :", entity_name))
  agg_fund_by_fiscal_year <- report_df %>%
    filter(name == entity_name) %>%
    pull(queried_transactions) %>%
    pluck(1) %>%
    pluck("transaction_report") %>%
    filter(fiscal_year < 2020) %>%
    compare_rev_exp(name,fund, fund_description, fiscal_year) %>% 
    mutate(fund_descr_code = paste(fund,fund_description))
  
  fund_faceted_plot <-
    ggplot(data = agg_fund_by_fiscal_year,
           aes(x = fund_descr_code,
               y = rev_minus_exp,
               fill = sord_category)) +
    geom_bar(stat = "identity") +
    coord_flip() +
    geom_text(
      aes(label = paste(
        "$", format(rev_minus_exp, big.mark = ",", trim = TRUE)
      )),
      color = "black",
      fontface = "bold",
      #vjust = 'inward',
      hjust = "inward",
      size = 3,
      alpha = .5
    ) +
    facet_grid(fiscal_year ~ .) +
    labs(
      title = paste("Fund - Fiscal Health Analysis"),
      subtitle = paste(entity_name)#,
    )+
    xlab("Fund")+
    ylab("Difference of Revenues and Expenditures") +
    scale_fill_manual(
      values = c(
        "surplus" = "#7CAE00",
        "deficit" = "#F8766D"
      )
    )
  
  
  
  fund_years <-
    agg_fund_by_fiscal_year %>% pull(fiscal_year) %>% unique()
  
  fund_individual_plots <-
    fund_years %>% map(plot_fund_by_year,entity_name=entity_name, agg_fund_by_fiscal_year)
  
  fund_plots <- list(fund_faceted_plot = fund_faceted_plot,
                     fund_individual_plots = fund_individual_plots)
  
  fund_health <- list(data = agg_fund_by_fiscal_year,
                      plots = fund_plots)
  
  
  
  #Funct Analysis
  agg_funct_by_fiscal_year <- report_df %>%
    filter(name == entity_name) %>%
    pull(queried_transactions) %>%
    pluck(1) %>%
    pluck("transaction_report") %>%
    filter(fiscal_year < 2020) %>%
    compare_rev_exp(name,funct, funct_description, fiscal_year) %>% 
    mutate(funct_descr_code = paste(funct,funct_description))
  
  funct_faceted_plot <-
    ggplot(data = agg_funct_by_fiscal_year,
           aes(x = funct_descr_code,
               y = rev_minus_exp,
               fill = sord_category)) +
    geom_bar(stat = "identity") +
    coord_flip() +
    geom_text(
      aes(label = paste(
        "$", format(rev_minus_exp, big.mark = ",", trim = TRUE)
      )),
      color = "black",
      fontface = "bold",
      #vjust = 'inward',
      hjust = "inward",
      size = 3,
      alpha = .5
    ) +
    facet_grid(fiscal_year ~ .) +
    labs(
      title = paste("Function - Fiscal Health Analysis"),
      subtitle = paste(entity_name))+
    xlab("Funct")+
    ylab("Difference of Revenues and Expenditures")+
    scale_fill_manual(
      values = c(
        "surplus" = "#7CAE00",
        "deficit" = "#F8766D"
      )
    )
  

  funct_years <-
    agg_funct_by_fiscal_year %>% pull(fiscal_year) %>% unique()
  
  funct_individual_plots <-
    funct_years %>% map(plot_funct_by_year,entity_name=entity_name, agg_funct_by_fiscal_year)
  


  
  #funct by Year
  entity_by_funct_year <- report_df %>%
    filter(name == entity_name) %>%
    pull(queried_transactions) %>%
    pluck(1) %>%
    pluck("transaction_report") %>%
    filter(fiscal_year < 2020) %>%
    compare_rev_exp(funct, funct_description, fiscal_year)
  
  funct_nums <- entity_by_funct_year %>% pull(funct) %>% unique()
  
  funct_by_year_plots<- funct_nums %>% map(plot_net_amount_by_funct,
                                           entity_name=entity_name,
                                           entity_by_funct_year)
  
  funct_plots <- list(funct_faceted_plot = funct_faceted_plot,
                   funct_individual_plots = funct_individual_plots,
                   funct_by_year_plots = funct_by_year_plots)
  
  funct_health <- list(data = agg_funct_by_fiscal_year,
                       plots = funct_plots)
  
  
  # Account Analysis
  entity_by_expenditures_year <- report_df %>%
    filter(name == entity_name) %>%
    pull(queried_transactions) %>%
    pluck(1) %>%
    pluck("transaction_report") %>%
    filter(fiscal_year < 2020) %>%
    agg_accounts(trxn_type = 1, account, account_description, fiscal_year)
  
  
  entity_by_revenues_year <- report_df %>%
    filter(name == entity_name) %>%
    pull(queried_transactions) %>%
    pluck(1) %>%
    pluck("transaction_report") %>%
    filter(fiscal_year < 2020) %>%
    agg_accounts(trxn_type = 2, account, account_description, fiscal_year)
  
  ## analyze all accounts in a year by year basis
  ### expenditures
  exp_years <-
    entity_by_expenditures_year %>% pull(fiscal_year) %>% unique()
  exp_plots <-
    exp_years %>% map(plot_account_by_year,entity_name=entity_name, entity_by_expenditures_year)
  exp_plots
  ### revenues
  rev_years <-
    entity_by_revenues_year %>% pull(fiscal_year) %>% unique()
  rev_plots <-
    rev_years %>% map(plot_account_by_year,entity_name=entity_name, entity_by_revenues_year)
  rev_plots
  
  plots_all_accounts_by_year <- list(exp_plots = exp_plots,
                                     rev_plots = rev_plots)
  
  ## analyze single accounts in a year by year basis
  ### expenditures
  
  #### get all of the expenditure accounts for that entity:
  account_nums <-
    entity_by_expenditures_year %>% pull(account) %>% unique()
  exp_plots <-
    account_nums %>% map(plot_net_amount_by_account,entity_name=entity_name, entity_by_expenditures_year)
  exp_plots
  
  #### get all of the revenues accounts for that entity:
  account_nums <-
    entity_by_revenues_year %>% pull(account) %>% unique()
  rev_plots <-
    account_nums %>% map(plot_net_amount_by_account,entity_name=entity_name, entity_by_revenues_year)
  rev_plots
  
  plots_single_account_by_year <- list(exp_plots = exp_plots,
                                       rev_plots = rev_plots)
  
  account_health <- list(revenue_data = entity_by_revenues_year, 
                         expenditure_data = entity_by_expenditures_year,
                         plots_single_account_by_year = plots_single_account_by_year,
                         plots_all_accounts_by_year = plots_all_accounts_by_year)
  
  fiscal_health <- list(fund_health = fund_health,
                        funct_health = funct_health,
                        account_health = account_health)
}
```

# VALIDATE AND CLEAN

## Load Lookup Table

```{r}
osa_lookup_file_name <- "osa_lookup.xlsx"

osa_lookup <- excel_sheets(osa_lookup_file_name) %>%
  map(read_excel, path = osa_lookup_file_name)

names(osa_lookup) <- c("fund", "funct", "account")

rm(osa_lookup_file_name)

```

browse the lookup tables
```{r,eval = FALSE}
osa_lookup
```

## Query Salesforce Data

```{r}
sf_entity_info <- 
  dbGetQuery(
    odbc_sf,
    "SELECT 
      a.Name                          AS name,
      a.Id                            AS id,
      a.Transparency_ID__c            AS t_id,
      a.Fiscal_Year_Begins__c         AS begin_fy,
      a.Expense_Revenue_Start_Date__c AS begin_report_er, 
      a.Wage_Start_Date__c            AS begin_report_w2,
      r.Name AS govt_type
    FROM Account         AS a
    LEFT JOIN RecordType AS r
      ON a.RecordTypeId = r.Id
    WHERE a.RecordTypeId IN (
      SELECT Id
      FROM RecordType
      WHERE SobjectType = 'Account'
      AND IsActive = 'TRUE'
      AND Name NOT IN (
        'Community User',
        'Component', -- This govt type contains local governments, but not ones for which we enforce compliance.
        'Court (Search Under Parent Entity)',
        'CPA Firm',
        'Educational Foundation or Component Unit', -- Not an entity we review for compliance.
        'Financial Institution',
        'Health Provider',
        'Non Profits'))
    AND a.Name NOT IN (
      'Intermountain Power Agency',
      'test city 2',
      'Utah Associated Municipal Power Systems',
      'Utah Municipal Power Agency')
    AND Entity_Status__c NOT IN ('Inactive', 'Dissolved')
    AND (
      a.Expense_Revenue_Start_Date__c <= DATE() OR
      a.Expense_Revenue_Start_Date__c IS NULL)") %>% 
  as_tibble() %>% 
  mutate(
  govt_type = 
    if_else(
      name %in% 
        c("State of Utah",
          "Utah System of Higher Education - Student Loan Guarantee Program",
          "Utah System of Higher Education - Student Loan Purchase Program",
          "Utah System of Higher Education - Utah Educational Savings Plan dba my529",
          "Utah System of Higher Education - Utah State Board of Regents"),
      "Monitored State Agency",
      govt_type)) %>% 
  filter(govt_type != "State of Utah (agencies/depts/comp units/ etc.)") %>% 
  # The State of Utah is required to report to Transparent Utah, but in most instances we do not monitor its data:
  filter(name != "State of Utah") #%>% 
  #select(-govt_type)

sf_exemptions <- 
  dbGetQuery(
    odbc_sf,
    paste("
          SELECT 
            a.Name                          AS name,
            t.Account__c                    AS id,
            a.Fiscal_Year_Begins__c         AS begin_fy,
            t.Transparency_type_exempted__c AS transaction_type,
            t.Recurring_Exemption__c        AS recurring_exemption,
            t.Exemption_Start_Date__c       AS exemption_start,
            t.Exemption_End_Date__c         AS exemption_end,
            t.Permanent_or_Temporary__c     AS exemption_type,
            t.Exemption_Reason__c           AS reason
          FROM (
            SELECT 
              Account__c,
              Exemption_Start_Date__c,
              Exemption_End_Date__c,
              Recurring_Exemption__c,
              Transparency_type_exempted__c,
              Permanent_or_Temporary__c,
              Exemption_Reason__c
            FROM Transparency_Exemption__c
            WHERE IsDeleted = FALSE) t
          LEFT JOIN Account a
          ON t.Account__c = a.Id
          WHERE a.Entity_Status__c IN (
            'Current', 
            'On hold', 
            'Delinquent', 
            'Suspended')
          AND a.Name != 'test city 2'")) %>% 
  as_tibble()

```

## Validate Salesforce Data
```{r}
validate_nrow(sf_entity_info, 1000)

# Validate sf_entity_info ####

if (class(sf_entity_info$name)            != "character" ||
    class(sf_entity_info$id)              != "character" ||
    class(sf_entity_info$t_id)            != "numeric"   ||
    class(sf_entity_info$begin_fy)        != "Date"      ||
    class(sf_entity_info$begin_report_er) != "Date"      ||
    class(sf_entity_info$begin_report_w2) != "Date") {

  stop("One or more fields in sf_entity_info is not of the correct class.
       Review the data before continuing.",
       call. = FALSE)  
}

if (sf_entity_info %>% 
    filter(is.na(name) | is.na(id)) %>% 
    nrow() > 0) {

  name_or_id_is_na <- 
    sf_entity_info %>% 
    filter(is.na(name) | is.na(id))
  
  stop("Entities should have a name and Salesforce ID.
       A missing name or Salesforce ID indicates some larger problem with the 
       data. Review and correct before continuing.",
       call. = FALSE)
}

if (sf_entity_info %>% 
    filter(is.na(begin_fy)) %>% 
    nrow() > 0) {
  
  missing_begin_fy <- 
    sf_entity_info %>% 
    filter(is.na(begin_fy))
  
  stop("begin_fy should be populated for every active government. Update 
       Salesforce and reimport before continuing.", call. = FALSE)
    }

if (sf_entity_info %>% 
    filter(
      !is.na(t_id) & (
        is.na(begin_report_er) |
        is.na(begin_report_w2))) %>% 
    nrow() > 0) {
  
  incomplete_info <- 
    sf_entity_info %>% 
    filter(
      !is.na(t_id) & (
        is.na(begin_report_er) |
        is.na(begin_report_w2)))
  
  stop("Entities with a Transparency ID must also have non-NA values for 
       begin_report_er and begin_report_w2 in
       order to determine their compliance status.",
       call. = FALSE)
}

if (sf_entity_info %>% 
    filter(begin_fy > today()) %>%
    nrow() > 0) {
  
  future_begin_fy <- 
    sf_entity_info %>% 
    filter(begin_fy > today())
  
  stop("Entities must not have a begin_fy value in the future.
       Correct and reimport before continuing.",
       call. = FALSE)
}

if (sf_entity_info %>% 
    filter(begin_fy <= (today() - months(12))) %>% 
    nrow() > 0) {
  
  sf_entity_info$begin_fy <- 
    sf_entity_info$begin_fy %>% 
    map_dbl(make_current_begin_fy)
  
  class(sf_entity_info$begin_fy) <- "Date"
}

if (sf_entity_info %>% 
    filter(month(begin_report_er) != month(begin_fy)) %>% 
    nrow() > 0) {
  
  begin_report_er_month_is_wrong <- 
    sf_entity_info %>% 
    filter(month(begin_report_er) != month(begin_fy))
  
  stop("The month of begin_report_er must match the month of begin_fy.
       Update in Salesforce (create an exemption if necessary) and reimport.",
       call. = FALSE)
}

if (sf_entity_info %>% 
    filter(month(begin_report_w2) != month(begin_fy)) %>% 
    nrow() > 0) {
  
  begin_report_w2_month_is_wrong <- 
    sf_entity_info %>% 
    filter(month(begin_report_w2) != month(begin_fy))
  
  stop("The month of begin_report_w2 must match the month of begin_fy.
       Update in Salesforce (create an exemption if necessary) and reimport.",
       call. = FALSE)
}

if (sf_entity_info %>% 
    filter(begin_report_w2 < begin_report_er) %>% 
    nrow() > 0) {
  
  w2_date_prior_to_exp_rev <- 
    sf_entity_info %>% 
    filter(begin_report_w2 < begin_report_er)
  
  stop("begin_report_w2 should not be earlier than
       begin_report_er. Update in Salesforce and reimport.", 
       call. = FALSE)
}
```



## Query Batches 

### Get subset of entities

Since we are making a fiscal health index, I think cities are a good starting point
```{r}
report <- sf_entity_info %>% 
  filter(govt_type == "City") %>% 
  mutate(batches = map(t_id ,query_batch_ids))
```


```{r, eval = FALSE}
# temp <- dbGetQuery(
#       odbc_aws,
#       paste(
#         "
#       SELECT e.name           AS name,
#       t.id             AS id,
#       t.batch_id       AS batch_id,
#       t.amount         AS amount,
#       t.fiscal_year    AS fiscal_year,
#       t.account_number AS account_number,
#       type
#       FROM transaction t
#       JOIN batch b
#         ON t.batch_id = b.id
#       JOIN entity e 
#         ON b.entity_id = e.id
#       WHERE t.batch_id IN (",
#       54158,
#       ") "
#       )
#     ) %>%
#     as_tibble()

```



Single batch examples -- show tae
```{r, eval = FALSE}
# 
# #vignettes of atomized uca
# temp <-
#   query_transactions(54158, osa_lookup) # contains incorrect length, form, and unmapped account code, it also shows how it can find the quaternary failure
# temp <-
#   query_transactions(54230, osa_lookup) # contains incorrect funct, and secondary funct code.
# temp <-
#   query_transactions(53818, osa_lookup) # contains incorrect account, and primary account code. 
```


```{r,eval=FALSE}
# temp
```

## EXECUTE: Validate entity uca
```{r}
# takes about 10 minutes
report <- report %>% slice(2:15)%>% 
  mutate(queried_transactions = batches %>% map(query_and_validate_transactions, lookup_table=osa_lookup))

```


```{r}
#view a single entities transaction reports.
report %>%
  filter(name=="Blanding City" ) %>%
  pull(queried_transactions) %>%
  pluck(1) %>% 
  pluck("transaction_report") %>% 
  #other interesting reports might something like "invalid_length" or "invalid_funct_code"
  head()
```

Conclusion: So at this point the data is cleaned. All cleaned UCA is in the "transaction_report" and all the transactions with erroronous uca is in one of the invalid reports. We can now do analysis on the transaction_report. 


# FISCAL HEALTH ANALYSIS
<!-- ##Boilerplates -->
<!-- ###generate some interesting aggregations for an entity -->
<!-- #### boilerplate for agg by account -->
<!-- ```{r, eval = FALSE} -->
<!-- entity_by_year <- report %>% -->
<!--   slice(1) %>% -->
<!--   pull(queried_transactions) %>% -->
<!--   pluck(1) %>% -->
<!--   pluck("transaction_report") %>% -->
<!--   agg_dollars_and_records(account_description, account, fiscal_year) -->


<!-- ``` -->
<!-- #### boilerplate for agg by funct -->
<!-- ```{r, eval = FALSE} -->
<!-- entity_by_year <- report %>% -->
<!--   slice(2) %>% -->
<!--   pull(queried_transactions) %>% -->
<!--   pluck(1) %>% -->
<!--   pluck("transaction_report") %>% -->
<!--   agg_dollars_and_records(funct_description, funct, fiscal_year) -->

<!-- ``` -->

## Single Entity Comparison 


### DEV: testing a single entity
```{r, eval = FALSE}
#note to get the names simply do : 
# report %>% pull(name) 

    name <- "Alpine City"
           #"Hildate City"
           #"Aurora City"
    single_entity_fiscal_health <- name %>% map(entity_fiscal_health_data, report)

```



```{r, eval = FALSE}
#single_entity_fiscal_health

single_entity_fiscal_health %>% pluck(1) %>% pluck("fund_health")

single_entity_fiscal_health %>% pluck(1) %>% pluck("funct_health") %>% pluck("plots") %>% pluck("funct_faceted_plot")

#single_entity_fiscal_health %>% pluck(1) %>% pluck("account_health")
```
### Remove Entities without any valid transaction reports:

```{r}
report <-report %>%  filter(name != "Hildale City" & name != "East Carbon City")
```
### Execute - Aggregations
```{r}
fiscal_health_report <- report %>%
  mutate(fiscal_health = name %>% map(entity_fiscal_health_data, report)) 

```

### Post Hoc Analysis -- DAVID
```{r}

e_name = "Alpine City" 
        #"Aurora City"

temp_report <- fiscal_health_report %>%
  filter(name == e_name) %>%
  pluck("fiscal_health") %>%
  pluck(1) %>%
  pluck("fund_health") # "funct_health" or "account_health"
```

Some plots are hard to see, so we can view them as a plotly object. 
```{r}
plotly <- temp_report %>%
  pluck("plots") %>%
  pluck("fund_faceted_plot") %>%
  ggplotly()

#run plotly in the console
```


###EXECUTE- Gen fiscal health index -- DAVID
```{r}
gen_fhi <- function(fhi_data){
  
  #suffix explanation: cy = current year, ay = all_years
  
  # MARK explanation
  # mark1 : 1 if number of funds in surplus is greater than number of funds in deficit this year;0 otherwise.
  # mark2 : 
  
  # Current Year Analysis ======================================================
  
  #fund analysis +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    fhi_fund_data_current_year <- fhi_data %>%
    pluck("fund_health") %>%
    pluck("data")  %>%
    filter(fiscal_year == "2019")
    
  # mark1 ----------------------------------------------------------------------

  sord_count_cy <- fhi_fund_data_current_year %>%
    group_by(sord_category) %>%
    summarize(n = n())

  if (sord_count_cy %>% filter(sord_category == "surplus") %>% nrow() == 0) {
    fund_surplus_count <- 0
  } else{
    fund_surplus_count<-sord_count_cy %>% filter(sord_category == "surplus") %>% pull(n)
  }

  if (sord_count_cy %>% filter(sord_category == "deficit") %>% nrow() == 0) {
    fund_deficit_count <- 0
  } else{
    fund_deficit_count<-sord_count_cy %>% filter(sord_category == "deficit") %>% pull(n)
  }

  #fund_total_count <- fund_surplus_count + fund_deficit_count

  if(fund_surplus_count > fund_deficit_count){
    mark1 = 1
  }else{
    mark1 = 0
  }
  
  ### MARK 2--------------------------------------------------------------------

  avg_cat_count_cy <- fhi_fund_data_current_year %>%
    ungroup() %>%
    mutate(avg_category  = fct_explicit_na(factor(avg_category))#,
           #avg_category  =avg_category %>% fct_expand("average", "above average","below average")
           ) %>%
    group_by(avg_category) %>%
    summarize(n = n())

  if (avg_cat_count_cy %>% filter(avg_category == "below average") %>% nrow() == 0) {
    fund_below_average_count <- 0
  } else{
    fund_below_average_count <-
      avg_cat_count_cy %>% filter(avg_category == "below average") %>% pull(n)
  }

  if (avg_cat_count_cy %>% filter(avg_category == "above average") %>% nrow() == 0) {
    fund_above_average_count <- 0
  } else{
    fund_above_average_count <-
      avg_cat_count_cy %>% filter(avg_category == "above average") %>% pull(n)
  }

  if (avg_cat_count_cy %>% filter(avg_category == "average") %>% nrow() == 0) {
    fund_average_count <- 0
  } else{
    fund_average_count <-
      avg_cat_count_cy %>% filter(avg_category == "average") %>% pull(n)
  }

  fund_avg_cat_total <- fund_below_average_count + fund_above_average_count + fund_average_count

  mark2 <- (fund_average_count + fund_above_average_count) / fund_avg_cat_total
  
  # mark3 ----------------------------------------------------------------------

  sord_magnitude_cy <- fhi_fund_data_current_year %>%
    mutate(surplus_only = case_when(sord_category == "surplus" ~ rev_minus_exp,
                                 sord_category == "deficit" ~ 0),
           deficit_only = case_when(sord_category == "deficit" ~ rev_minus_exp,
                                 sord_category == "surplus" ~ 0),
           )
  
  fund_surplus_sum <- sord_magnitude_cy %>% pull(surplus_only) %>% sum()
  fund_deficit_sum <- sord_magnitude_cy %>% pull(deficit_only) %>% sum()

  mark3 <- fund_surplus_sum / (abs(fund_surplus_sum) + abs(fund_deficit_sum))
  
  

  
  
  # Function Analysis ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  
  ##*Put function analysis here*##
  
  
  # Account Analysis +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  
  ##*Put account analysis here*##
  
################################################################################  
  # Five Year analysis =========================================================
  
  # Fund Analysis ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  
  fhi_fund_data_five_year <- fhi_data %>%
    pluck("fund_health") %>%
    pluck("data") 
  
  
  # Mark 4 ---------------------------------------------------------------------
  sord_count_ay <- fhi_fund_data_five_year %>%
    group_by(sord_category) %>%
    summarize(n = n())
  
  if (sord_count_ay %>% filter(sord_category == "surplus") %>% nrow() == 0) {
    fund_surplus_count <- 0
  } else{
    fund_surplus_count <-
      sord_count_ay %>% filter(sord_category == "surplus") %>% pull(n)
  }
  
  if (sord_count_ay %>% filter(sord_category == "deficit") %>% nrow() == 0) {
    fund_deficit_count <- 0
  } else{
    fund_deficit_count <-
      sord_count_ay %>% filter(sord_category == "deficit") %>% pull(n)
  }
  
  #fund_total_count <- fund_surplus_count + fund_deficit_count
  
  if (fund_surplus_count > fund_deficit_count) {
    mark4 = 1
  } else{
    mark4 = 0
  }
  
  # mark 5 ---------------------------------------------------------------------
  
  avg_cat_count_ay <- fhi_fund_data_five_year %>%
    ungroup() %>%
    mutate(avg_category  = fct_explicit_na(factor(avg_category))#,
           #avg_category  =avg_category %>% fct_expand("average", "above average","below average")
           ) %>%
    group_by(avg_category) %>%
    summarize(n = n())

  if (avg_cat_count_ay %>% filter(avg_category == "below average") %>% nrow() == 0) {
    fund_below_average_count <- 0
  } else{
    fund_below_average_count <-
      avg_cat_count_ay %>% filter(avg_category == "below average") %>% pull(n)
  }

  if (avg_cat_count_ay %>% filter(avg_category == "above average") %>% nrow() == 0) {
    fund_above_average_count <- 0
  } else{
    fund_above_average_count <-
      avg_cat_count_ay %>% filter(avg_category == "above average") %>% pull(n)
  }

  if (avg_cat_count_ay %>% filter(avg_category == "average") %>% nrow() == 0) {
    fund_average_count <- 0
  } else{
    fund_average_count <-
      avg_cat_count_ay %>% filter(avg_category == "average") %>% pull(n)
  }

  fund_avg_cat_total <- fund_below_average_count + fund_above_average_count + fund_average_count

  mark5 <- (fund_average_count + fund_above_average_count) / fund_avg_cat_total
  
  # Function Analysis ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  
  ##*Put function analysis here*##
  
  
  # Account Analysis +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  
  ##*Put account analysis here*##  
  
  
  
################################################################################  
  # Consolidate ================================================================
  # total_marks <-  list(mark1 = mark1,
  #                      mark2 = mark2,
  #                      mark3 = mark3,
  #                      total_marks = total_marks)
  
  total_marks <- mark1 + mark2 + mark3 +
    mark4 + mark5
  
}
```
```{r}

fiscal_health_index <- tibble::rowid_to_column(fiscal_health_report, "row_id") 

fiscal_health_index <- fiscal_health_index %>% 
  rowwise() %>% 
  mutate(
    fhi = gen_fhi(fiscal_health))
```

```{r}
fiscal_health_index %>% select(name, fhi)
```

look at 'fiscally health' entity
```{r, eval = FALSE}
fiscal_health_index %>% filter(name == "Ballard Town") %>% pull(fiscal_health) %>% pluck(1) %>% pluck("fund_health")
```

Look at the 'fiscally unhealthy' entity
```{r, eval = FALSE}
fiscal_health_index %>% filter(name == "Beaver City") %>% pull(fiscal_health) %>% pluck(1) %>% pluck("fund_health")
```



#Cross Entity===================================================================
this area is not finished yet. I am still working through the process. 

```{r}
test_nums <- 1:10

test_df<- fiscal_health_index %>% mutate(
  fund_data = rowid %>% map(test_function, report_df = fiscal_health_index) 
)

test_df <- test_nums %>% map(test_function, report_df = fiscal_health_index) 

total_df <- bind_rows(test_df)

```

```{r}
test_function <- function(temp_num, report_df){
    temp_data <- report_df %>%
    slice(temp_num) %>%
    pull(fiscal_health) %>%
    pluck(1) %>%
    pluck("fund_health") %>%
    pluck("data")
}
```


```{r}
total_df <- total_df %>%
  group_by(fund) %>%
  mutate(cross_avg = mean(rev_minus_exp),
         cross_sd  = sd(rev_minus_exp)) %>%
  mutate(cross_avg_cateogry = case_when (
    rev_minus_exp > cross_avg + cross_sd ~ "above_average",
    rev_minus_exp < cross_avg - cross_sd ~ "below_average",
    TRUE ~ "average", 
  ))

```

```{r}
cross_plot_fund_by_year <- function(fiscal_years,entity_name, df) {
  fiscal_years <- enquo(fiscal_years)
  df <- df %>% filter(fiscal_year == !!fiscal_years)
  
  ggplot(data = df,
         aes(x = fund_descr_code,
             y = rev_minus_exp,
             fill = cross_sord_category)) +
    geom_bar(stat = "identity") +
    coord_flip() +
    geom_text(
      aes(label = paste(
        "$", format(rev_minus_exp, big.mark = ",", trim = TRUE)
      )),
      color = "black",
      fontface = "bold",
      #vjust = 'inward',
      hjust = "inward",
      size = 4,
      alpha = .5
    ) +
    labs(
      title = paste("Fund- Cross Fiscal Health Analysis - Fiscal Year: ", as_label(fiscal_years)),
      subtitle = paste(entity_name)
    ) +
    scale_fill_manual(
      values = c(
        "average" = "#00BFC4",
        "below average" = "#F8766D",
        "above average" = "#7CAE00"
      )
    ) +
        xlab("Fiscal Year") +
      ylab("Difference of Revenues and Expenditures")
  
}
```


