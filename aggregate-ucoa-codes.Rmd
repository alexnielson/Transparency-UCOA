# 0. Program Description

**Purpose**
I am interested in learning more about how to access and pay with the UCOA codes. I decided to conduct some Exploratory Data Analysis in this document as well. This script is not really meant for a single button run-all. It rather is built to allow a data analyst to play around with the data easily. It does contain a few basic reports and interesting plots. 

DURATION: the script will take about 20-30 minutes to run.

**Input(s)**

```{r}
dsn_aws        <- "transpAWS"
dsn_salesforce <- "salesforce"
```

**Output(s)**


# I. Libraries and Data Sources

```{r}
library(lubridate)
library(magrittr)
library(odbc)
library(readxl) 
library(tidyverse)

odbc_aws <- dbConnect(odbc::odbc(), dsn_aws)
odbc_sf  <- dbConnect(odbc::odbc(), dsn_salesforce)

rm(dsn_aws, dsn_salesforce)

download.file(
  "http://financialreports.utah.gov/chartofaccounts/ChartofAccountFull.xlsx",
  "ucoa.xlsx",
  mode = "wb")
```


# II.Function Definitions

DONT FORGET TO ADD ALL OF THESE LATER...

# III. LOAD, QUERY, and WRANGLE

## Salesforce - Query

```{r}
# Note that I do not query LEAs. They are managed by USBE, which uses a
# different chart of accounts. I also do not query higher education.

# sf_data <-
#   dbGetQuery(
#     odbc_sf,
#     paste("
#           SELECT
#             Account.Name                  AS name,
#             Account.Id                    AS id,
#             Account.Transparency_ID__c    AS t_id,
#             Account.Fiscal_Year_Begins__c AS begin_fy,
#             RecordType.DeveloperName      AS govt_type
#           FROM Account
#           JOIN RecordType
#           ON Account.RecordTypeId = RecordType.Id
#           WHERE Account.RecordTypeId IN (
#             SELECT Id
#             FROM RecordType
#             WHERE DeveloperName IN (
#             'AOG',
#             'City',
#             'Conservation_District',
#             'County',
#             'District_Health',
#             'Housing',
#             'Independent_Quasi_State_Entity',
#             'Interlocal',
#             'Local_and_Special_Service_District',
#             'Mental_Health',
#             'Redevelopment_Agency_Project_Area',
#             'Town'))
#           AND Account.Entity_Status__c IN (
#             'Current',
#             'On hold',
#             'Delinquent',
#             'Suspended')
#           AND Account.Name NOT IN (
#             'Intermountain Power Agency',
#             'Utah Associated Municipal Power Systems',
#             'Utah Municipal Power Agency')
#           AND (
#             Account.Expense_Revenue_Start_Date__c <= DATE() OR
#             Account.Expense_Revenue_Start_Date__c IS NULL)")) %>%
#   as_tibble()
```

## UCOA - load and wrangle

```{r}
#note that excel_sheets() returns a list, hence the list access syntax.
#access in this way since it is a xlsx file.
ucoa_fund <- 
  read_xlsx("ucoa.xlsx", sheet = excel_sheets("ucoa.xlsx")[[1]] )

ucoa_function <- 
  read_xlsx("ucoa.xlsx", sheet = excel_sheets("ucoa.xlsx")[[2]] )

ucoa_account <- 
  read_xlsx("ucoa.xlsx", sheet = excel_sheets("ucoa.xlsx")[[3]] )

#Since the xlsx file was built to be readable, and not necessarily easily
#parsed, the first two rows must be cleaned. 

#fix the column names
colnames(ucoa_fund)     <- ucoa_fund[2, ]
colnames(ucoa_function) <- c("NUMBER", ucoa_function[1, 2:4])
colnames(ucoa_account)  <- ucoa_account[2, ]

#remove the useless rows.
ucoa_fund     <- ucoa_fund     %>% slice(-1, -2)
ucoa_function <- ucoa_function %>% slice(-1)
ucoa_account  <- ucoa_account  %>% slice(-1, -2)


extra_fund_numbers <-
  c(201:299, 301:399, 401:449, 451:499, 501:599, 601:699, 701:799) %>%
  as.character() %>%
  enframe(name = NULL) %>%
  rename("NUMBER" = "value") %>%
  mutate("SHORT DESCRIPTION" = NA,
         `FULL DESCRIPTION` = case_when(
            NUMBER %in% (201:299) ~ "Special Revenue Funds (as assigned by local government)",
            NUMBER %in% (301:399) ~ "Debt Service Funds (as assigned by local government)",
            NUMBER %in% (401:449) ~ "Capital Projects Funds (as assigned by local government)",
            NUMBER %in% (451:499) ~ "Permanent Funds (as assigned by local government)",
            NUMBER %in% (501:599) ~ "Enterprise Funds (as assigned by local government)",
            NUMBER %in% (601:699) ~ "Internal Service Funds (as assigned by local government)",
            NUMBER %in% (701:799) ~ "Trust and Agency Funds (as assigned by local government)"
                                        ),
         "DETAIL" = NA
    
         )

ucoa_fund <-
  ucoa_fund %>%
  bind_rows(extra_fund_numbers)

#fix some other random formattings. ie: 10 ==> 010

ucoa_fund$NUMBER[[1]]     <- "010"
ucoa_fund$NUMBER[[2]]     <- "020"
ucoa_fund$NUMBER[[3]]     <- "030"
ucoa_function$NUMBER[[1]] <- "000000"

#we want a table of just account expenditures
ucoa_account_exp <-
  ucoa_account %>% 
  filter(str_detect(NUMBER, "^4"))# filter for any row which starts with 4,
                                  # this is because UCoA attributes anything in 
                                  # the 3000-3999 to revenues

#we also want a table of just account revenues. 
ucoa_account_rev <- 
  ucoa_account %>% 
  filter(str_detect(NUMBER, "^3"))# filter for any row which starts with 3
                                  # this is because UCoA attribtes anything in
                                  # the 3000-3999 to revenues

#if we want a table of just w2 information, then we should run this code too.  
# ucoa_account_w2 <- 
#   ucoa_account %>% 
#   filter(str_detect(NUMBER, "^4001"))


ucoa_vague_funct <- 
  ucoa_function %>% 
  filter(                #DESCRIPTION OF FUNCTION
    NUMBER == "000000" | # Not Applicable
    NUMBER == "100000" | # General Government
    NUMBER == "200000" | # Public Safety
    NUMBER == "300000" | # Public Works
    NUMBER == "400000" | # Health
    NUMBER == "500000")  # Community

ucoa_vague_exp <- 
  ucoa_account_exp %>% 
  filter(                  # DESCRIPTION of Expeditures accounts
    NUMBER == "40000000" | # Expenditures
    NUMBER == "40010000" | # Personnel Services
    NUMBER == "40020000" | # General and Contracted Services
    NUMBER == "40030000" | # Utilities and Utility Services
    NUMBER == "40040000" | # Taxes and Fees
    NUMBER == "40050000" | # Supplies and Materials
    NUMBER == "40060000" | # Grants and Contracts
    NUMBER == "40070000" | # Direct Payments
    NUMBER == "40080000" | # Capital Outlays
      # Notice that I think that 40090000 Interdepartmental Charges, and
      # 40100000 Judgements and Losses are considered non-vague. Since they
      # cannot be broken down further. If this ever change then we would need to
      # include them here.
    NUMBER == "40110000" | # Other financing Uses
      # As noted above, 40120000:40160000 cannot be broken down into more
      # specific accounts
    NUMBER == "40170000" ) # Debt Service

ucoa_vague_rev <- 
  ucoa_account_rev %>% 
  filter(                  # DESCRIPTION OF Revenue accounts
    NUMBER == "30000000" | # Revenues
    NUMBER == "30010000" | # Taxes
    NUMBER == "30020000" | # Licenses and Permits
    NUMBER == "30030000" | # Intergovernmental
    NUMBER == "30040000" | # Charges For Service
    NUMBER == "30050000" | # Fines and Forfeitures
    NUMBER == "30060000" | # Miscellaneous
    NUMBER == "30070000" ) # Other Sources of Funding

ucoa_lookup <-
  list(
    fund        = ucoa_fund,
    funct       = ucoa_function,
    account     = ucoa_account,
    account_exp = ucoa_account_exp,
    account_rev = ucoa_account_rev,
    vague_funct = ucoa_vague_funct,
    vague_exp   = ucoa_vague_exp,
    vague_rev   = ucoa_vague_rev)

rm(ucoa_fund, ucoa_function, ucoa_account, extra_fund_numbers, ucoa_account_exp,
   ucoa_account_rev, ucoa_vague_funct, ucoa_vague_exp, ucoa_vague_rev)
```

## LEA UCOA - load and wrangle
```{r}
#put code here to generate a useful lea ucoa. 
library(stringi) 

#Alex, you could fix this by doing the case whens with %in% instead of >, <, =

# Wrangle and fix the fund =====================================================
lea_ucoa_fund <-
  read_xlsx("lea_ucoa_2020.xlsx", sheet = excel_sheets("lea_ucoa_2020.xlsx")[[1]])

lea_ucoa_fund<- lea_ucoa_fund %>%
  replace(is.na(.), "") %>% 
  unite(NUMBER_DESCRIPTION, c(1:2), sep= " ") %>% 
  mutate(NUMBER_DESCRIPTION = trimws(NUMBER_DESCRIPTION) ) %>% 
  filter(NUMBER_DESCRIPTION != "") %>% 
  slice(6:n()) %>% 
  filter(str_detect(NUMBER_DESCRIPTION, regex("^[[:digit:]]{2}"))) %>%
   # get rid of rows which have a range ie: 27-29 and 61-69
  filter(!str_detect(NUMBER_DESCRIPTION, regex("[[:digit:]]{2}-"))) %>% 
  filter(!str_detect(NUMBER_DESCRIPTION, regex("[[:digit:]]{2} -"))) %>% 
  mutate(
    NUMBER = stri_extract_first(NUMBER_DESCRIPTION, regex = "\\w+"),
    DESCRIPTION = stri_extract_first(NUMBER_DESCRIPTION, regex = "\\s(.*)")
  )

##add back the ranges
extra_fund_numbers <- c(27:29, 61:69) %>%
  as.character() %>%
  enframe(name = NULL) %>%
  rename("NUMBER" = "value") %>%
  mutate(
    "DESCRIPTION" =
      case_when(
        NUMBER < 30 ~ "Special Revenue Funds - (Assigned by District)",
        NUMBER > 60 &  NUMBER < 70 ~ "Interal Service Fund - (Assigned by District)"
      ),
    "NUMBER_DESCRIPTION" = paste(NUMBER, DESCRIPTION)
  )

lea_ucoa_fund <-
  lea_ucoa_fund %>%
  bind_rows(extra_fund_numbers)



# Wrangle "Location" ===========================================================
# lea_ucoa_Location <-
#   read_xlsx("lea_ucoa_2019.xlsx", sheet = excel_sheets("lea_ucoa_2019.xlsx")[[2]])
# 
# lea_ucoa_Location<- lea_ucoa_Location %>% select(NUMBER_DESCRIPTION = 1) %>% 
#   replace(is.na(.),"") %>% 
#   filter(NUMBER_DESCRIPTION != "") %>% 
#   slice(3:n())
#   
lea_ucoa_location<- c(0:499,600:999) %>%
  # str_pad(3, pad = "0") %>% 
  as.character() %>%
  enframe(name = NULL) %>%
  rename("NUMBER" = "value") %>%
    mutate( "DESCRIPTION" =
      case_when(
        as.numeric(NUMBER) <= 10    ~ "Pre School",
        as.numeric(NUMBER) >= 11 & as.numeric(NUMBER) <= 99   ~ "District Level",
        as.numeric(NUMBER) >= 100 & as.numeric(NUMBER) <= 299 ~ "Elementary Schools",
        as.numeric(NUMBER) >= 300 & as.numeric(NUMBER) <= 399 ~ "Middle Schools",
        as.numeric(NUMBER) >= 400 & as.numeric(NUMBER) <= 499 ~ "Junior High Schools/Middle Schools",
        as.numeric(NUMBER) >= 600 & as.numeric(NUMBER) <= 699 ~ "Special Schools, Secondary",
        as.numeric(NUMBER) >= 700 & as.numeric(NUMBER) <= 799 ~ "High Schools",
        as.numeric(NUMBER) >= 800 & as.numeric(NUMBER) <= 899 ~ "Special Schools, Elementary",
        as.numeric(NUMBER) >= 900 & as.numeric(NUMBER) <= 975 ~ "Private Schools",
        as.numeric(NUMBER) >= 976 & as.numeric(NUMBER) <= 999 ~ "Adult Education Schools",
      )) %>% 
  mutate(NUMBER = NUMBER %>% str_pad(3, pad = "0")) %>% 
  mutate("NUMBER_DESCRIPTION" = paste(NUMBER, DESCRIPTION))
  

# Wrangle "program" ============================================================

lea_ucoa_program <-
  read_xlsx("lea_ucoa_2020.xlsx", sheet = excel_sheets("lea_ucoa_2020.xlsx")[[3]])

lea_ucoa_program<- lea_ucoa_program %>% 
  replace(is.na(.), "") %>% 
  unite(NUMBER_DESCRIPTION, c(1:9), sep= " ") %>% 
  mutate(NUMBER_DESCRIPTION = trimws(NUMBER_DESCRIPTION) ) %>% 
  filter(NUMBER_DESCRIPTION != "") %>% 
  slice(6:n()) %>% 
  filter(str_detect(NUMBER_DESCRIPTION, regex("^[[:digit:]]{4}"))) %>%
   # get rid of rows which have a # but are a range ie: 27-29 and 61-69
  filter(!str_detect(NUMBER_DESCRIPTION, regex("[[:digit:]]{4}-"))) %>% 
  filter(!str_detect(NUMBER_DESCRIPTION, regex("[[:digit:]]{4} -"))) %>% 
  mutate(
    NUMBER = stri_extract_first(NUMBER_DESCRIPTION, regex = "\\w+"),
    DESCRIPTION = stri_extract_first(NUMBER_DESCRIPTION, regex = "\\s(.*)")
  )

extra_program_numbers<- c(2000:3699, # 2000 SCHOOL LEVEL PROGRAMS
                          5251:5290,  
                          7804:7809,
                          7811:7819,
                          7821:7829,
                          7831:7839,
                          7841:7849,
                          7851:7859,
                          7871:7879,
                          7891:7899,
                          7916:7919,
                          7911:7914,
                          7921:7929,
                          7931:7939,
                          7941:7949,
                          7951:7959) %>%
  as.character() %>%
  enframe(name = NULL) %>%
  rename("NUMBER" = "value") %>% 
    mutate( "DESCRIPTION" =
      case_when(
        NUMBER >= 2000 & NUMBER <= 2099~ "General School",
        NUMBER >= 2100 & NUMBER <= 2199~ "General Studentbody",
        NUMBER >= 2200 & NUMBER <= 3299~ "Instructional Classes",
        NUMBER >= 3300 & NUMBER <= 3599~ "Other Instructional Classes",
        NUMBER >= 3600 & NUMBER <= 3699~ "Student Activity Funds",
        
        NUMBER >= 5251 & NUMBER <= 5259~ "OTHER MINIMUM SCHOOL PROGRAMS - Reserved for Numbers Assigned by Districts",
        NUMBER >= 5260 & NUMBER <= 5269~ "OTHER MINIMUM SCHOOL PROGRAMS - Reserved for Numbers Assigned by Districts",
        NUMBER >= 5270 & NUMBER <= 5290~ "OTHER MINIMUM SCHOOL PROGRAMS - Reserved for Numbers Assigned by Districts",

        NUMBER >= 7804 & NUMBER <= 7809~ "(NCLB) Numbers reserved for districts",
        NUMBER >= 7811 & NUMBER <= 7819~ "(NCLB) Numbers reserved for districts",
        NUMBER >= 7821 & NUMBER <= 7829~ "(NCLB) Numbers reserved for districts",
        NUMBER >= 7831 & NUMBER <= 7839~ "(NCLB) Numbers reserved for districts",
        NUMBER >= 7841 & NUMBER <= 7849~ "(NCLB) Numbers reserved for districts",
        NUMBER >= 7851 & NUMBER <= 7859~ "(NCLB) Numbers reserved for districts",
        NUMBER >= 7871 & NUMBER <= 7879~ "(NCLB) Numbers reserved for districts",
        NUMBER >= 7891 & NUMBER <= 7899~ "(NCLB) Numbers reserved for districts",
        NUMBER >= 7916 & NUMBER <= 7919~ "(NCLB) Numbers reserved for districts",
        NUMBER >= 7911 & NUMBER <= 7914~ "(NCLB) Numbers reserved for districts",
        NUMBER >= 7921 & NUMBER <= 7929~ "(NCLB) Numbers reserved for districts",
        NUMBER >= 7931 & NUMBER <= 7939~ "(NCLB) Numbers reserved for districts",
        NUMBER >= 7941 & NUMBER <= 7949~ "(NCLB) Numbers reserved for districts",
        NUMBER >= 7951 & NUMBER <= 7959~ "(NCLB) Numbers reserved for districts"
      ),
      "NUMBER_DESCRIPTION" = paste(NUMBER, DESCRIPTION))

lea_ucoa_program <-
  lea_ucoa_program %>%
  bind_rows(extra_program_numbers)  

# Wrangle "Function" ===========================================================
lea_ucoa_function <-
  read_xlsx("lea_ucoa_2020.xlsx", sheet = excel_sheets("lea_ucoa_2020.xlsx")[[4]])

lea_ucoa_function<- lea_ucoa_function %>% 
  replace(is.na(.), "") %>% 
  unite(NUMBER_DESCRIPTION, c(1:9), sep= " ") %>% 
  mutate(NUMBER_DESCRIPTION = trimws(NUMBER_DESCRIPTION) ) %>% 
  filter(NUMBER_DESCRIPTION != "") %>% 
  slice(6:n()) %>% 
  filter(str_detect(NUMBER_DESCRIPTION, regex("^[[:digit:]]{4}"))) %>%
  # filter(!str_detect(NUMBER_DESCRIPTION, regex("[[:digit:]]{4}-"))) %>% 
  # filter(!str_detect(NUMBER_DESCRIPTION, regex("[[:digit:]]{4} -"))) %>% 
  mutate(
    NUMBER = stri_extract_first(NUMBER_DESCRIPTION, regex = "\\w+"),
    DESCRIPTION = stri_extract_first(NUMBER_DESCRIPTION, regex = "\\s(.*)")
  )

# Wrangle "Object" =============================================================

lea_ucoa_object <-
  read_xlsx("lea_ucoa_2020.xlsx", sheet = excel_sheets("lea_ucoa_2020.xlsx")[[5]])

lea_ucoa_object<- lea_ucoa_object %>% 
  replace(is.na(.), "") %>% 
  unite(NUMBER_DESCRIPTION, c(1:8), sep= " ") %>% 
  mutate(NUMBER_DESCRIPTION = trimws(NUMBER_DESCRIPTION) ) %>% 
  filter(NUMBER_DESCRIPTION != "") %>% 
  slice(6:n()) %>% 
  filter(str_detect(NUMBER_DESCRIPTION, regex("^[[:digit:]]{3}"))) %>%
  # filter(!str_detect(NUMBER_DESCRIPTION, regex("[[:digit:]]{4}-"))) %>% 
  # # filter(!str_detect(NUMBER_DESCRIPTION, regex("[[:digit:]]{4} -"))) %>% 
  mutate(
    NUMBER = stri_extract_first(NUMBER_DESCRIPTION, regex = "\\w+"),
    DESCRIPTION = stri_extract_first(NUMBER_DESCRIPTION, regex = "\\s(.*)")
  )

# Wrangle "Revenue Classification" =============================================
lea_ucoa_revenue_classification <-
  read_xlsx("lea_ucoa_2020.xlsx", sheet = excel_sheets("lea_ucoa_2020.xlsx")[[6]])

lea_ucoa_revenue_classification<- lea_ucoa_revenue_classification %>% replace(is.na(.), "") %>% 
  unite(NUMBER_DESCRIPTION, c(1:9), sep= " ") %>% 
  mutate(NUMBER_DESCRIPTION = trimws(NUMBER_DESCRIPTION) ) %>% 
  filter(NUMBER_DESCRIPTION != "") %>% 
  slice(6:n()) %>% 
  filter(str_detect(NUMBER_DESCRIPTION, regex("^[[:digit:]]{3}"))) %>%
  # filter(!str_detect(NUMBER_DESCRIPTION, regex("[[:digit:]]{4}-"))) %>% 
  # # filter(!str_detect(NUMBER_DESCRIPTION, regex("[[:digit:]]{4} -"))) %>% 
  mutate(
    NUMBER = stri_extract_first(NUMBER_DESCRIPTION, regex = "\\w+"),
    DESCRIPTION = stri_extract_first(NUMBER_DESCRIPTION, regex = "\\s(.*)")
  )

#consolidate
lea_ucoa_lookup <- list(
  fund                   = lea_ucoa_fund,
  location               = lea_ucoa_location,
  program                = lea_ucoa_program,
  funct                  = lea_ucoa_function,
  object                 = lea_ucoa_object,
  revenue_classification = lea_ucoa_revenue_classification
)


rm(
  lea_ucoa_fund,
  lea_ucoa_location,
  lea_ucoa_function,
  lea_ucoa_program,
  lea_ucoa_revenue_classification,
  lea_ucoa_object,
  extra_program_numbers,
  extra_fund_numbers
)
```
```{r}
lea_ucoa_lookup %>% pluck("location")

```



#IV. Load and Validate UCOA codes
 *We will vadidate the code to remove missing values, and "". Then generate for three main reports. The first report contains both invalid LEA and NON-LEA codes. THe second report will be valid LEA codes (lea_reported_ucoa). The third report will be valid NON-LEA codes (I call it osa_reported_ucoa)
```{r}

# Query the database, get all the records that are not obviously missing data. 
reported_ucoa <-
dbGetQuery(
  odbc_aws,
  paste("
        SELECT id, 
        batch_id,
        amount,
        fiscal_year,
        account_number,
        type
        FROM transaction
        WHERE account_number IS NOT NULL
        LIMIT 10000000")) %>% # note I am limitingto 10000000 so it doesn't take an eternity.
as_tibble() 

# double check for NA or "" ----------------------------------------------------

invalid_reported_na_or_empty <- reported_ucoa %>%
  filter(account_number=="",
        is.na(account_number))

reported_ucoa <- 
  reported_ucoa %>% 
  filter(account_number != "", !is.na(account_number))


#check correct length ----------------------------------------------------------

# 19 is for normal, 25 is for LEA. (dashes are included in string legth)
invalid_ucoa_length <- reported_ucoa %>% 
  filter(nchar(account_number) != 19 && !nchar(account_number)!= 25) %>% 
  mutate(account_number_length = nchar(account_number),
         reason = case_when(account_number_length < 19 ~ "uca code too short for non LEA",
                            account_number_length > 19 ~ "uca code incorrect length",
                            account_number_length > 25 ~ "uca code too long for LEA"))

reported_ucoa <- reported_ucoa %>% 
  filter(nchar(account_number) == 19 || nchar(account_number)== 25)


# Generate temp tibbles --------------------------------------------------------
# this will help with the subsequent reports. You could condense this, but for
# my mind this is easier to debugg and catch flaws. 

#filter for only lea
lea_reported_ucoa <- reported_ucoa %>% filter(nchar(account_number)== 25)

#filter for non lea
osa_reported_ucoa <- reported_ucoa %>% filter(nchar(account_number)== 19)

# lea ==========================================================================

# check if the codes are valid form. ie: ##-###-####-####-###-#### 
 
invalid_lea_ucoa_code <-
  lea_reported_ucoa %>%
  filter(!str_detect(
    lea_reported_ucoa$account_number,
    regex(
      "^[:digit:]{2}-[:alnum:]{3}-[:digit:]{4}-[:digit:]{4}-[:digit:]{3}-[:digit:]{4}$"
    )
  ))

lea_reported_ucoa <-
  lea_reported_ucoa %>%
  filter(str_detect(
    lea_reported_ucoa$account_number,
    regex(
      "^[:digit:]{2}-[:alnum:]{3}-[:digit:]{4}-[:digit:]{4}-[:digit:]{3}-[:digit:]{4}$"
    )
  ))

# non lea ====================================================================== 

# check if the codes are valid form. ie: ###-######-########  

invalid_osa_ucoa_codes <- osa_reported_ucoa %>%
  filter(!str_detect(
    osa_reported_ucoa$account_number,
    regex("^[:digit:]{3}-[:digit:]{6}-[:digit:]{8}$")
  ))

osa_reported_ucoa <-
  osa_reported_ucoa %>%
  filter(str_detect(
    osa_reported_ucoa$account_number,
    regex("^[:digit:]{3}-[:digit:]{6}-[:digit:]{8}$")
  ))

# consolidate ==================================================================
osa_ucoa <- osa_reported_ucoa
lea_ucoa <- lea_reported_ucoa
invalid_tables <-
  list(invalid_reported_na_or_empty,
       invalid_ucoa_length,
       invalid_lea_ucoa_code,
       invalid_osa_ucoa_codes)
names(invalid_tables) <- c("na_or_empty",
                           "invalid_length",
                           "invalid_lea_format",
                           "invalid_osa_format")

# remove unneeded objects ======================================================
# comment any object that you want to inspect in the global environment pane
rm(
  invalid_reported_na_or_empty,
  invalid_lea_ucoa_code,
  invalid_osa_ucoa_codes,
  invalid_ucoa_length,
  osa_reported_ucoa,
  lea_reported_ucoa,
  reported_ucoa
)
  
```


### Enrich non - LEA ucoa tibble 
```{r}
# This breaks out the account numbers into fund, function, and account. 
osa_ucoa <- osa_ucoa %>% 
  mutate(
    fund = .[["account_number"]] %>% substr(0, 3),
    funct = .[["account_number"]] %>% substr(5, 10),
    account = .[["account_number"]] %>%  substr(12, 19),
  ) %>% 

# Now we need to join ucoa.xlsx, so we know what the codes mean.

# join the funds
left_join(ucoa_lookup[["fund"]] %>%
            as_tibble() %>%
            select(NUMBER, fund_description =`FULL DESCRIPTION`),
          by = c("fund"="NUMBER")
          ) %>% 
# join the functions
left_join(ucoa_lookup[["funct"]] %>%
            as_tibble() %>%
            select(NUMBER, function_description = `FULL DESCRIPTION`),
          by = c("funct" = "NUMBER")
          ) %>% 
# join the accounts
left_join(ucoa_lookup[["account"]] %>% 
            as_tibble() %>% 
            select(NUMBER, account_description = `FULL DESCRIPTION`),
          by = c("account" = "NUMBER")
          )
```
#### Validate the non LEA UCOA codes

#### Find a list of entities who used codes which do no map to the UCA. 
*There are many reasons why this might be the case 
**They are using an old UCOA
**They pressed the incorrect key / typos
...regardless, they must be filtered out. 

```{r}
#find wrong fund code
osa_bad_fund_code <- osa_ucoa %>%
  filter(!fund %in% (ucoa_lookup %>%
                       pluck("fund")  %>%
                       select(NUMBER) %>%
                       unlist()))
#find wrong function code
osa_bad_funct_code<-osa_ucoa %>%
  filter(!funct %in% (ucoa_lookup %>%
                        pluck("funct") %>%
                        select(NUMBER) %>%
                        unlist()))
#find wrong account code
osa_bad_account_code <- osa_ucoa %>%
  filter(!account %in% (ucoa_lookup %>%
                          pluck("account") %>%
                          select(NUMBER)   %>%
                          unlist()))


#now remove incorrectly mapped. we will save them to report, but do not want them in our analysis.

osa_ucoa<- osa_ucoa %>% 
  anti_join(osa_bad_fund_code, by = "id") %>% 
  anti_join(osa_bad_funct_code, by = "id") %>% 
  anti_join(osa_bad_account_code, by = "id")



#consolidate
osa_non_mapping <- list(osa_bad_fund_code,osa_bad_funct_code,osa_bad_account_code)
names(osa_non_mapping) <- c("unmapped_fund_code","unmapped_funct_code","unmapped_account_code")


#remove objects
rm(osa_bad_fund_code,osa_bad_funct_code,osa_bad_account_code)
```
add "osa_non_mapping" to the invalid tables list
```{r}
invalid_tables <- c(invalid_tables, osa_non_mapping)
```

##### Export the invalid tables
```{r}
#since the invalid tables is large list, we should export the invalid tables, and then remove that list. 
# Do this at the end, once we are done writing the program.
```

## Enrich the LEA ucoa
```{r}
# This breaks out the account numbers into fund, function, and account. 
lea_ucoa <- lea_ucoa %>% 
  mutate(
    fund                   = .[["account_number"]] %>% substr(0, 2),
    location               = .[["account_number"]] %>% substr(4, 6),
    program                = .[["account_number"]] %>%  substr(8, 11),
    funct                  = .[["account_number"]] %>%  substr(13, 16),
    object                 = .[["account_number"]] %>%  substr(18, 20),
    revenue_classification = .[["account_number"]] %>%  substr(22, 25),
  ) %>% 

# temp_lea_ucoa<- lea_ucoa %>% 
#   mutate(
#     fund                   = .[["account_number"]] %>% substr(0, 2),
#     location               = .[["account_number"]] %>% substr(4, 6),
#     program                = .[["account_number"]] %>%  substr(8, 11),
#     funct                  = .[["account_number"]] %>%  substr(13, 16),
#     object                 = .[["account_number"]] %>%  substr(18, 20),
#     revenue_classification = .[["account_number"]] %>%  substr(22, 25),
#   ) %>% 
# Now we need to join ucoa.xlsx, so we know what the codes mean.

# join the funds
left_join(lea_ucoa_lookup %>%
            pluck("fund") %>%
            select(NUMBER, fund_description =`DESCRIPTION`),
          by = c("fund"="NUMBER")
          ) %>%
# join the functions
left_join(lea_ucoa_lookup %>%
            pluck("location") %>%
            select(NUMBER, location_description = `DESCRIPTION`),
          by = c("location" = "NUMBER")
          ) %>% 
# join the accounts
left_join(lea_ucoa_lookup %>% 
            pluck("program") %>% 
            select(NUMBER, program_description = `DESCRIPTION`),
          by = c("program" = "NUMBER")
          ) %>% 
left_join(lea_ucoa_lookup %>% 
            pluck("funct") %>%
          select(NUMBER, function_description = `DESCRIPTION`),
        by = c("funct" = "NUMBER")
        ) %>% 
left_join(lea_ucoa_lookup %>% 
            pluck("object") %>%
            select(NUMBER, object_description = `DESCRIPTION`),
          by = c("object" = "NUMBER")
          ) %>% 
left_join(lea_ucoa_lookup %>% 
            pluck("revenue_classification") %>%
            select(NUMBER, rev_class_description = `DESCRIPTION`),
          by = c("revenue_classification" = "NUMBER")
          )
```

#### Find a list of entities who used codes which do no map to the LEA UCA. 
*There are many reasons why this might be the case 
**They are using an old UCOA
**They pressed the incorrect key / typos
...regardless, they must be filtered out. 

```{r}
#find wrong fund code
lea_bad_fund_code <- lea_ucoa %>%
  filter(!fund %in% (lea_ucoa_lookup %>%
                       pluck("fund")  %>%
                       select(NUMBER) %>%
                       unlist()))

#find wrong location code
lea_bad_location_code<-lea_ucoa %>%
  filter(!location %in% (lea_ucoa_lookup %>%
                        pluck("location") %>%
                        select(NUMBER) %>%
                        unlist()))
#find wrong program code
lea_bad_program_code <- lea_ucoa %>%
  filter(!program %in% (lea_ucoa_lookup %>%
                          pluck("program") %>%
                          select(NUMBER)   %>%
                          unlist()))

lea_bad_funct_code <- lea_ucoa %>%
  filter(!funct %in% (lea_ucoa_lookup %>%
                          pluck("funct") %>%
                          select(NUMBER)   %>%
                          unlist()))

lea_bad_object_code <- lea_ucoa %>%
  filter(!object %in% (lea_ucoa_lookup %>%
                          pluck("object") %>%
                          select(NUMBER)   %>%
                          unlist()))

lea_bad_revenue_classification_code <- lea_ucoa %>%
  filter(!revenue_classification %in% (lea_ucoa_lookup %>%
                          pluck("revenue_classification") %>%
                          select(NUMBER)   %>%
                          unlist()))

#now remove incorrectly mapped. we will save them to report, but do not want them in our analysis.

lea_ucoa<- lea_ucoa %>% 
  anti_join(lea_bad_fund_code, by = "id") %>% 
  anti_join(lea_bad_location_code, by = "id") %>% 
  anti_join(lea_bad_program_code, by = "id") %>% 
  anti_join(lea_bad_funct_code, by = "id") %>% 
  anti_join(lea_bad_object_code, by = "id") %>% 
  anti_join(lea_bad_revenue_classification_code, by = "id")



#consolidate
lea_non_mapping <-
  list(
    lea_bad_fund_code,
    lea_bad_location_code,
    lea_bad_program_code,
    lea_bad_funct_code,
    lea_bad_object_code,
    lea_bad_revenue_classification_code
  )
names(lea_non_mapping) <-
  c(
    "lea_unmapped_fund_code",
    "lea_unmapped_location_code",
    "lea_unmapped_program_code",
    "lea_unmapped_funct_code",
    "lea_unmapped_object_code",
    "lea_unmapped_revenue_classification_code"
  )


#remove objects
rm(lea_bad_fund_code,
    lea_bad_location_code,
    lea_bad_program_code,
    lea_bad_funct_code,
    lea_bad_object_code,
    lea_bad_revenue_classification_code)
```

```{r}
invalid_tables <- c(invalid_tables, lea_non_mapping)
rm(lea_non_mapping)
```

#V. Aggregate Tables

## Aggregate Tables for non-LEAs

### Aggregate by descrition and number/code
```{r}


agg_fund_amount <-  osa_ucoa %>% 
  group_by(fund_description, fund) %>% 
  summarize(total_amount = sum(amount),
            num_of_trans = n() ) %>% 
  arrange(desc(total_amount))
  
agg_function_amount <-  osa_ucoa %>% 
  group_by(function_description, funct) %>% 
  summarize(total_amount = sum(amount),
            num_of_trans = n() ) %>% 
  arrange(desc(total_amount))

agg_account_amount <-  osa_ucoa %>% 
  group_by(account_description, account) %>% 
  summarize(total_amount = sum(amount),
            num_of_trans = n() ) %>% 
  arrange(desc(total_amount))


agg_by_description_and_code<- list(agg_fund_amount,agg_function_amount,agg_account_amount)
names(agg_by_description_and_code) <- c("agg_fund", "agg_function", "agg_account")

rm(agg_fund_amount,agg_function_amount,agg_account_amount)

```
*!NOTE: the next two aggregations are only useful if the data is not properly cleaned or entered. If every code has a mapped description, then only the above agg table is necessary.*

### Aggregate by description only
```{r}


agg_fund_amount <-  osa_ucoa %>% 
  group_by(fund_description) %>% 
  summarize(total_amount = sum(amount),
            num_of_trans = n() ) %>% 
  arrange(desc(total_amount))
  
agg_function_amount <-  osa_ucoa %>% 
  group_by(function_description) %>% 
  summarize(total_amount = sum(amount),
            num_of_trans = n() ) %>% 
  arrange(desc(total_amount))

agg_account_amount <-  osa_ucoa %>% 
  group_by(account_description) %>% 
  summarize(total_amount = sum(amount),
            num_of_trans = n() ) %>% 
  arrange(desc(total_amount))


agg_by_description<- list(agg_fund_amount,agg_function_amount,agg_account_amount)
names(agg_by_description) <- c("agg_fund", "agg_function", "agg_account")

rm(agg_fund_amount,agg_function_amount,agg_account_amount)

```

### Aggregate by Code
```{r}


agg_fund_amount <-  osa_ucoa %>% 
  group_by( fund) %>% 
  summarize(total_amount = sum(amount),
            num_of_trans = n() ) %>% 
  arrange(desc(total_amount))
  
agg_function_amount <-  osa_ucoa %>% 
  group_by(funct) %>% 
  summarize(total_amount = sum(amount),
            num_of_trans = n() ) %>% 
  arrange(desc(total_amount))

agg_account_amount <-  osa_ucoa %>% 
  group_by(account) %>% 
  summarize(total_amount = sum(amount),
            num_of_trans = n() ) %>% 
  arrange(desc(total_amount))


agg_by_code<- list(agg_fund_amount,agg_function_amount,agg_account_amount)
names(agg_by_code) <- c("agg_fund", "agg_function", "agg_account")

rm(agg_fund_amount,agg_function_amount,agg_account_amount)

```

```{r}
#consolidate into one list

osa_agg_tables <- list(agg_by_description_and_code, agg_by_description,agg_by_code)
names(osa_agg_tables) <- c("agg_by_description_and_code","agg_by_description", "agg_by_code")
rm(agg_by_description_and_code,agg_by_description,agg_by_code)
```










#VI. Visualizations

##visualizae aggregate tables

### Visualizing the the "Fund" category
```{r}
#create a simple barplot to show the different types of ucoa codes for funds only

agg_fund_plot <-  osa_agg_tables %>%
  pluck("agg_by_description") %>%
  pluck("agg_fund") %>% 
  ggplot(aes(x = fund_description, y = total_amount)) + geom_bar(stat = "identity", fill = "lightcoral") +
  coord_flip() +
  geom_text(
    aes(label = paste0("$", total_amount)),
    hjust = -.25,
    vjust = 0,
    size = 2
  ) +
  labs(title = "Barplot of Cumulative Net Amount ($) by Description",
       x = "Description of Fund",
       y = "Cumulative Net Amount ($)")

agg_fund_plot
```


###visualizing the "Function" category
```{r}

```


### visualize the "Account" category

#### visualize revenue by code
```{r}


plot_in_range <- function(temp_range){
  
  p <- osa_agg_tables %>% 
      pluck("agg_by_code") %>% 
      pluck("agg_account") %>% 
      filter(str_detect(account, paste0("^",temp_range))) %>% #only selects taxes
      ggplot(aes(x=account, y=total_amount))+ geom_bar(stat = "identity", fill = "lightcoral")+
      coord_flip()+
      geom_text(aes(label=paste0("$",total_amount)), hjust = -.25,vjust=0, size=3)+
      labs(title = paste0("Barplot of UCOA Account in Range: ", temp_range,"0000") )
  p
  
}

temp_sequence_revenues <- seq(from = 3000, to = 3009,  by=1)

revenue_plots<- temp_sequence_revenues %>% map(plot_in_range)
names(revenue_plots) <- c("revenues",
                  "taxes",
                  "licenses_and_permits",
                  "intergovernmental",
                  "charges_for_service",
                  "fines_and_forfeitures",
                  "miscellaneous",
                  "other_sources_of_funding",
                  "special_and_extraordinary_gain",
                  "suspense")

temp_sequence_expenditures <- seq(from = 4000, to = 4017,  by=1)

expenditure_plots<- temp_sequence_expenditures %>% map(plot_in_range)
names(expenditure_plots) <- c("expenditures",
                  "personnel_services",
                  "general_and_contracted_services",
                  "utilities_and_utility_services",
                  "taxes_and_fees",
                  "supplies_and_materials",
                  "grants_and_contracts",
                  "direct_payments",
                  "capital_outlays",
                  "interdepartmental_charges",
                  "judgements_and_losses",
                  "other_financing_uses",
                  "depreciation",
                  "amortiaton",
                  "bad_debt_expense",
                  "contingencies",
                  "special_and_extraordinary_loss",
                  "debt_service")

#consolidate objects
account_plots <- list(revenue_plots, expenditure_plots)
names(account_plots) <- c("revenue_plots", "expenditure_plots")

#remove redundant objects
rm(temp_sequence_revenues, temp_sequence_expenditures, revenue_plots, expenditure_plots)
```
##### view the plots
```{r}
#to see all plot simply run:
account_plots

```
To only view the revenue plots, we pluck it from the list.
```{r}
temp <- account_plots %>% pluck("revenue_plots") 
temp
```
If you are only interested in one plot, use the following code
```{r}
temp <- account_plots %>% 
  pluck("expenditure_plots") %>% 
  pluck("capital_outlays")
temp
```


To access elements of the plot, use this code format. The code below selects the data frame used to generate the plot from 
```{r}
temp_zoom <- account_plots %>% 
  pluck("revenue_plots") %>%
  pluck("intergovernmental") %>%
  pluck("data")
```


#### visualize revenue by description
 if the data is properly cleaned then this chunk is redundant. 
```{r}


plot_in_range <- function(temp_range){
  
  p <- osa_agg_tables %>% 
      pluck("agg_by_description_and_code") %>% 
      pluck("agg_account") %>% 
      filter(str_detect(account, paste0("^",temp_range))) %>% #only selects taxes
      ggplot(aes(x=account_description, y=total_amount))+ geom_bar(stat = "identity", fill = "lightcoral")+
      coord_flip()+
      geom_text(aes(label=paste0("$",total_amount)), hjust = -.25,vjust=0, size=3)+
      labs(title = paste0("Barplot of Account Revenues in Range: ", temp_range,"0000") )
  p
  
}

temp_sequence_revenues <- seq(from = 3000, to = 3009,  by=1)

revenue_plots<- temp_sequence_revenues %>% map(plot_in_range)
names(revenue_plots) <- c("revenues",
                  "taxes",
                  "licenses_and_permits",
                  "intergovernmental",
                  "charges_for_service",
                  "fines_and_forfeitures",
                  "miscellaneous",
                  "other_sources_of_funding",
                  "special_and_extraordinary_gain",
                  "suspense")

temp_sequence_expenditures <- seq(from = 4000, to = 4017,  by=1)

expenditure_plots<- temp_sequence_expenditures %>% map(plot_in_range)
names(expenditure_plots) <- c("expenditures",
                  "personnel_services",
                  "general_and_contracted_services",
                  "utilities_and_utility_services",
                  "taxes_and_fees",
                  "supplies_and_materials",
                  "grants_and_contracts",
                  "direct_payments",
                  "capital_outlays",
                  "interdepartmental_charges",
                  "judgements_and_losses",
                  "other_financing_uses",
                  "depreciation",
                  "amortiaton",
                  "bad_debt_expense",
                  "contingencies",
                  "special_and_extraordinary_loss",
                  "debt_service")

#consolidate objects
account_plots <- list(revenue_plots, expenditure_plots)
names(account_plots) <- c("revenue_plots", "expenditure_plots")

#remove redundant objects
rm(temp_sequence_revenues, temp_sequence_expenditures, revenue_plots, expenditure_plots)
```

```{r}
account_plots %>% pluck("revenue_plots")
```


You can access plot elements to quickly zoom in on the data. for example:
```{r}
#temp_zoom <- plots %>% pluck("intergovernmental") %>% pluck("data")
```

#VII. Generate Invalid Report

## na_or_empty : Examine transactions with na or empty value for their account number
```{r}
invalid_tables %>% pluck("na_or_empty")
```

## invalid_length : Examine transactions with an account number too long or too small to fit either LEA or non-LEA UCOA.
```{r}
invalid_tables %>% pluck("invalid_length")
```

## invalid_lea_format : Examine transactions for LEAs with an account number with correct length, but incorrect format
```{r}
invalid_tables %>% pluck("invalid_lea_format")
```


## invalid_osa_format : Examine transactions for non LEAs with an account number with correct length, but incorrect format
```{r}
invalid_tables %>% pluck("invalid_osa_format")
```

## unmapped_fund_code : Examine transactions for non LEAs with an account number with correct length, and correct format, but the fund code provided does not map to the ucoa code spreadsheet
```{r}
invalid_tables %>% pluck("unmapped_fund_code")
```


## unmapped_fund_code : Examine transactions for non LEAs with an account number with correct length, and correct format, but the function code provided does not map to the ucoa code spreadsheet
```{r}
invalid_tables %>% pluck("unmapped_funct_code")
```
## unmapped_account_code : Examine transactions for non LEAs with an account number with correct length, and correct format, but the account code provided does not map to the ucoa code spreadsheet
```{r}
invalid_tables %>% pluck("unmapped_account_code")
```

## lea_unmapped_fund_code : Examine transactions for non LEAs with an account number with correct length, and correct format, but the account code provided does not map to the ucoa code spreadsheet

```{r}
invalid_tables %>% pluck("lea_unmapped_fund_code")
```

## lea_unmapped_location_code : Examine transactions for non LEAs with an account number with correct length, and correct format, but the account code provided does not map to the ucoa code spreadsheet

```{r}
invalid_tables %>% pluck("lea_unmapped_location_code")
```

## lea_unmapped_program_code : Examine transactions for non LEAs with an account number with correct length, and correct format, but the account code provided does not map to the ucoa code spreadsheet

```{r}
invalid_tables %>% pluck("lea_unmapped_program_code")
```

## lea_unmapped_funct_code : Examine transactions for non LEAs with an account number with correct length, and correct format, but the account code provided does not map to the ucoa code spreadsheet

```{r}
invalid_tables %>% pluck("lea_unmapped_funct_code")
```

## lea_unmapped_object_code : Examine transactions for non LEAs with an account number with correct length, and correct format, but the account code provided does not map to the ucoa code spreadsheet

```{r}
invalid_tables %>% pluck("lea_unmapped_object_code")
```

## lea_unmapped_revenue_classification_code : Examine transactions for non LEAs with an account number with correct length, and correct format, but the account code provided does not map to the ucoa code spreadsheet

```{r}
invalid_tables %>% pluck("lea_unmapped_revenue_classification_code")
```


