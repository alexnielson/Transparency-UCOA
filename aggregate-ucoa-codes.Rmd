# ---
# title = "ucoa master doc"
# output = html-document
# ---

# 0. Program Description

**Purpose**
I am interested in learning more about how to access and pay with the UCOA codes. I decided to conduct some Exploratory Data Analysis in this document as well. This script is not really meant for a single button run-all. It rather is built to allow a data analyst to play around with the data easily. It does contain a few basic reports and interesting plots. 

DURATION: the script will take about 20-30 minutes to run.

**Input(s)**

```{r}
dsn_aws        <- "transpAWS"
dsn_salesforce <- "salesforce"
```

**Output(s)**


# I. Libraries and Data Sources

```{r}
library(lubridate)
library(magrittr)
library(odbc)
library(readxl) 
library(tidyverse)
library(stringi) 

odbc_aws <- dbConnect(odbc::odbc(), dsn_aws)
odbc_sf  <- dbConnect(odbc::odbc(), dsn_salesforce)

rm(dsn_aws, dsn_salesforce)

download.file(
  "http://financialreports.utah.gov/chartofaccounts/ChartofAccountFull.xlsx",
  "ucoa.xlsx",
  mode = "wb")
```


# II.Function Definitions

```{r}
agg_dollars_and_records<- function(df, ...){
  # Purpose: groups the data by supplied grouping variables, and aggregates the
  # date to have a total dollar amount and a count for the number of transactions
  # with such variables. Basically this will group uca codings into dollar and
  # frequency amounts. Two metrics of interest to Alex.
  #
  # Inputs: *df (tibble or dataframe): a dataframe which has the grouping variables. it should have an amount column
  #         *... : the grouping variables. should be a uca field.
  # Outputs: tibble :an aggregated tibble
  
  grouping_vars <- enquos(...)
  
  agg_table <- df %>% 
    group_by(!!! grouping_vars) %>% 
    summarize(total_amount = sum(amount),
              num_of_trans = n()) %>% 
    arrange(desc(total_amount))
  
}
```
# III. LOAD, QUERY, and WRANGLE

## OSA UCOA 

```{r}
# note that excel_sheets() returns a list, hence the list access syntax. 
ucoa_fund <-
  read_xlsx("ucoa.xlsx", sheet = excel_sheets("ucoa.xlsx")[[1]])

ucoa_function <-
  read_xlsx("ucoa.xlsx", sheet = excel_sheets("ucoa.xlsx")[[2]])

ucoa_account <-
  read_xlsx("ucoa.xlsx", sheet = excel_sheets("ucoa.xlsx")[[3]])

#Since the xlsx file was built to be readable, and not necessarily easily
#parsed, the first two rows must be cleaned.

#fix the column names
colnames(ucoa_fund)     <- ucoa_fund[2,]
colnames(ucoa_function) <- c("NUMBER", ucoa_function[1, 2:4])
colnames(ucoa_account)  <- ucoa_account[2,]

#remove the useless rows.
ucoa_fund     <- ucoa_fund     %>% slice(-1, -2)
ucoa_function <- ucoa_function %>% slice(-1)
ucoa_account  <- ucoa_account  %>% slice(-1, -2)


#Add additional fund numbers.
extra_fund_numbers <-
  c(202:298, 302:398, 402:448, 452:498, 502:598, 602:698, 702:798) %>%
  as.character() %>%
  enframe(name = NULL) %>%
  rename("NUMBER" = "value") %>%
  mutate(
    "SHORT DESCRIPTION" = NA,
    `FULL DESCRIPTION` = case_when(
      NUMBER %in% (202:298) ~ "Special Revenue Funds (as assigned by local government)",
      NUMBER %in% (302:398) ~ "Debt Service Funds (as assigned by local government)",
      NUMBER %in% (402:448) ~ "Capital Projects Funds (as assigned by local government)",
      NUMBER %in% (452:498) ~ "Permanent Funds (as assigned by local government)",
      NUMBER %in% (502:598) ~ "Enterprise Funds (as assigned by local government)",
      NUMBER %in% (602:698) ~ "Internal Service Funds (as assigned by local government)",
      NUMBER %in% (702:798) ~ "Trust and Agency Funds (as assigned by local government)"
    ),
    "DETAIL" = NA
  )

ucoa_fund <-
  ucoa_fund %>%
  bind_rows(extra_fund_numbers)

#fix some other random formattings. ie: 10 ==> 010

ucoa_fund$NUMBER[[1]]     <- "010"
ucoa_fund$NUMBER[[2]]     <- "020"
ucoa_fund$NUMBER[[3]]     <- "030"
ucoa_function$NUMBER[[1]] <- "000000"

#we want a table of just account expenditures
ucoa_account_exp <-
  ucoa_account %>% 
  filter(str_detect(NUMBER, "^4"))# filter for any row which starts with 4,
                                  # this is because UCoA attributes anything in 
                                  # the 3000-3999 to revenues

#we also want a table of just account revenues. 
ucoa_account_rev <- 
  ucoa_account %>% 
  filter(str_detect(NUMBER, "^3"))# filter for any row which starts with 3
                                  # this is because UCoA attribtes anything in
                                  # the 3000-3999 to revenues

#if we want a table of just w2 information, then we should run this code too.  
# ucoa_account_w2 <- 
#   ucoa_account %>% 
#   filter(str_detect(NUMBER, "^4001"))


#Consolidate ===================================================================
ucoa_lookup <-
  list(
    fund        = ucoa_fund,
    funct       = ucoa_function,
    account     = ucoa_account,
    account_exp = ucoa_account_exp,
    account_rev = ucoa_account_rev,
    vague_funct = ucoa_vague_funct,
    vague_exp   = ucoa_vague_exp,
    vague_rev   = ucoa_vague_rev)

```
Remove unneeded objects
```{r}
rm(ucoa_fund, ucoa_function, ucoa_account, extra_fund_numbers, ucoa_account_exp,
   ucoa_account_rev, ucoa_vague_funct, ucoa_vague_exp, ucoa_vague_rev)
```


## LEA UCOA
```{r}
# Wrangle and fix the fund =====================================================
lea_ucoa_fund <-
  read_xlsx("lea_ucoa_2020.xlsx", sheet = excel_sheets("lea_ucoa_2020.xlsx")[[1]])

lea_ucoa_fund<- lea_ucoa_fund %>%
  replace(is.na(.), "") %>% 
  unite(NUMBER_DESCRIPTION, c(1:2), sep= " ") %>% 
  mutate(NUMBER_DESCRIPTION = trimws(NUMBER_DESCRIPTION) ) %>% 
  filter(NUMBER_DESCRIPTION != "") %>% 
  slice(6:n()) %>% 
  filter(str_detect(NUMBER_DESCRIPTION, regex("^[[:digit:]]{2}"))) %>%
   # get rid of rows which have a range ie: 27-29 and 61-69
  filter(!str_detect(NUMBER_DESCRIPTION, regex("[[:digit:]]{2}-"))) %>% 
  filter(!str_detect(NUMBER_DESCRIPTION, regex("[[:digit:]]{2} -"))) %>% 
  mutate(
    NUMBER = stri_extract_first(NUMBER_DESCRIPTION, regex = "\\w+"),
    DESCRIPTION = stri_extract_first(NUMBER_DESCRIPTION, regex = "\\s(.*)")
  )

##add back the ranges
extra_fund_numbers <- c(27:29, 61:69) %>%
  as.character() %>%
  enframe(name = NULL) %>%
  rename("NUMBER" = "value") %>%
  mutate(
    "DESCRIPTION" =
      case_when(
        NUMBER %in% (27:29) ~ "Special Revenue Funds - (Assigned by District)",
        NUMBER %in% (61:69) ~ "Interal Service Fund - (Assigned by District)"
      ),
    "NUMBER_DESCRIPTION" = paste(NUMBER, DESCRIPTION)
  )

lea_ucoa_fund <-
  lea_ucoa_fund %>%
  bind_rows(extra_fund_numbers)

# Wrangle "Location" ===========================================================   
lea_ucoa_location<- c(0:499,600:999) %>%
  # str_pad(3, pad = "0") %>% 
  as.character() %>%
  enframe(name = NULL) %>%
  rename("NUMBER" = "value") %>%
    mutate( "DESCRIPTION" =
      case_when(
        as.numeric(NUMBER) <= 10    ~ "Pre School",
        as.numeric(NUMBER) >= 11 & as.numeric(NUMBER) <= 99   ~ "District Level",
        NUMBER %in% (100:299) ~ "Elementary Schools",
        NUMBER %in% (300:399) ~ "Middle Schools",
        NUMBER %in% (400:499) ~ "Junior High Schools/Middle Schools",
        NUMBER %in% (600:699) ~ "Special Schools, Secondary",
        NUMBER %in% (700:799) ~ "High Schools",
        NUMBER %in% (800:899) ~ "Special Schools, Elementary",
        NUMBER %in% (900:975) ~ "Private Schools",
        NUMBER %in% (976:999) ~ "Adult Education Schools"
      )) %>% 
  mutate(NUMBER = NUMBER %>% str_pad(3, pad = "0")) %>% 
  mutate("NUMBER_DESCRIPTION" = paste(NUMBER, DESCRIPTION))
  

# Wrangle "program" ============================================================
lea_ucoa_program <-
  read_xlsx("lea_ucoa_2020.xlsx", sheet = excel_sheets("lea_ucoa_2020.xlsx")[[3]])

lea_ucoa_program <- lea_ucoa_program %>%
  replace(is.na(.), "") %>%
  unite(NUMBER_DESCRIPTION, c(1:9), sep = " ") %>%
  mutate(NUMBER_DESCRIPTION = trimws(NUMBER_DESCRIPTION)) %>%
  filter(NUMBER_DESCRIPTION != "") %>%
  slice(6:n()) %>%
  filter(str_detect(NUMBER_DESCRIPTION, regex("^[[:digit:]]{4}"))) %>%
  # get rid of rows which have a # but are a range ie: 27-29 and 61-69
  filter(!str_detect(NUMBER_DESCRIPTION, regex("[[:digit:]]{4}-"))) %>%
  filter(!str_detect(NUMBER_DESCRIPTION, regex("[[:digit:]]{4} -"))) %>%
  mutate(
    NUMBER = stri_extract_first(NUMBER_DESCRIPTION, regex = "\\w+"),
    DESCRIPTION = stri_extract_first(NUMBER_DESCRIPTION, regex = "\\s(.*)")
  )

extra_program_numbers <- c(
  2000:3699,
  # 2000 SCHOOL LEVEL PROGRAMS
  5251:5290,
  7804:7809,
  7811:7819,
  7821:7829,
  7831:7839,
  7841:7849,
  7851:7859,
  7871:7879,
  7891:7899,
  7916:7919,
  7911:7914,
  7921:7929,
  7931:7939,
  7941:7949,
  7951:7959
) %>%
  as.character() %>%
  enframe(name = NULL) %>%
  rename("NUMBER" = "value") %>%
  mutate(
    "DESCRIPTION" =
      case_when(
        NUMBER %in% (2000:2099) ~ "General School",
        NUMBER %in% (2100:2199) ~ "General Studentbody",
        NUMBER %in% (2200:3299) ~ "Instructional Classes",
        NUMBER %in% (3300:3599) ~ "Other Instructional Classes",
        NUMBER %in% (3600:3699) ~ "Student Activity Funds",
        
        NUMBER %in% (5251:5259) ~ "OTHER MINIMUM SCHOOL PROGRAMS - Reserved for Numbers Assigned by Districts",
        NUMBER %in% (5260:5269) ~ "OTHER MINIMUM SCHOOL PROGRAMS - Reserved for Numbers Assigned by Districts",
        NUMBER %in% (5270:5290) ~ "OTHER MINIMUM SCHOOL PROGRAMS - Reserved for Numbers Assigned by Districts",
        
        NUMBER %in% (7804:7809) ~ "(NCLB) Numbers reserved for districts",
        NUMBER %in% (7811:7819) ~ "(NCLB) Numbers reserved for districts",
        NUMBER %in% (7821:7829) ~ "(NCLB) Numbers reserved for districts",
        NUMBER %in% (7831:7839) ~ "(NCLB) Numbers reserved for districts",
        NUMBER %in% (7841:7849) ~ "(NCLB) Numbers reserved for districts",
        NUMBER %in% (7851:7859) ~ "(NCLB) Numbers reserved for districts",
        NUMBER %in% (7871:7879) ~ "(NCLB) Numbers reserved for districts",
        NUMBER %in% (7891:7899) ~ "(NCLB) Numbers reserved for districts",
        NUMBER %in% (7916:7919) ~ "(NCLB) Numbers reserved for districts",
        NUMBER %in% (7911:7914) ~ "(NCLB) Numbers reserved for districts",
        NUMBER %in% (7921:7929) ~ "(NCLB) Numbers reserved for districts",
        NUMBER %in% (7931:7939) ~ "(NCLB) Numbers reserved for districts",
        NUMBER %in% (7941:7949) ~ "(NCLB) Numbers reserved for districts",
        NUMBER %in% (7951:7959) ~ "(NCLB) Numbers reserved for districts"
      ),
    "NUMBER_DESCRIPTION" = paste(NUMBER, DESCRIPTION)
  )

lea_ucoa_program <-
  lea_ucoa_program %>%
  bind_rows(extra_program_numbers)  

# Wrangle "Function" ===========================================================
lea_ucoa_function <-
  read_xlsx("lea_ucoa_2020.xlsx", sheet = excel_sheets("lea_ucoa_2020.xlsx")[[4]])

lea_ucoa_function<- lea_ucoa_function %>% 
  replace(is.na(.), "") %>% 
  unite(NUMBER_DESCRIPTION, c(1:9), sep= " ") %>% 
  mutate(NUMBER_DESCRIPTION = trimws(NUMBER_DESCRIPTION) ) %>% 
  filter(NUMBER_DESCRIPTION != "") %>% 
  slice(6:n()) %>% 
  filter(str_detect(NUMBER_DESCRIPTION, regex("^[[:digit:]]{4}"))) %>%
  # filter(!str_detect(NUMBER_DESCRIPTION, regex("[[:digit:]]{4}-"))) %>% 
  # filter(!str_detect(NUMBER_DESCRIPTION, regex("[[:digit:]]{4} -"))) %>% 
  mutate(
    NUMBER = stri_extract_first(NUMBER_DESCRIPTION, regex = "\\w+"),
    DESCRIPTION = stri_extract_first(NUMBER_DESCRIPTION, regex = "\\s(.*)")
  )

# Wrangle "Object" =============================================================

lea_ucoa_object <-
  read_xlsx("lea_ucoa_2020.xlsx", sheet = excel_sheets("lea_ucoa_2020.xlsx")[[5]])

lea_ucoa_object <- lea_ucoa_object %>%
  replace(is.na(.), "") %>%
  unite(NUMBER_DESCRIPTION, c(1:8), sep = " ") %>%
  mutate(NUMBER_DESCRIPTION = trimws(NUMBER_DESCRIPTION)) %>%
  filter(NUMBER_DESCRIPTION != "") %>%
  slice(6:n()) %>%
  filter(str_detect(NUMBER_DESCRIPTION, regex("^[[:digit:]]{3}"))) %>%
  # filter(!str_detect(NUMBER_DESCRIPTION, regex("[[:digit:]]{4}-"))) %>%
  # # filter(!str_detect(NUMBER_DESCRIPTION, regex("[[:digit:]]{4} -"))) %>%
  mutate(
    NUMBER = stri_extract_first(NUMBER_DESCRIPTION, regex = "\\w+"),
    DESCRIPTION = stri_extract_first(NUMBER_DESCRIPTION, regex = "\\s(.*)")
  )

# Wrangle "Revenue Classification" =============================================
lea_ucoa_revenue_classification <-
  read_xlsx("lea_ucoa_2020.xlsx", sheet = excel_sheets("lea_ucoa_2020.xlsx")[[6]])

lea_ucoa_revenue_classification <-
  lea_ucoa_revenue_classification %>% replace(is.na(.), "") %>%
  unite(NUMBER_DESCRIPTION, c(1:9), sep = " ") %>%
  mutate(NUMBER_DESCRIPTION = trimws(NUMBER_DESCRIPTION)) %>%
  filter(NUMBER_DESCRIPTION != "") %>%
  slice(6:n()) %>%
  filter(str_detect(NUMBER_DESCRIPTION, regex("^[[:digit:]]{3}"))) %>%
  # filter(!str_detect(NUMBER_DESCRIPTION, regex("[[:digit:]]{4}-"))) %>%
  # # filter(!str_detect(NUMBER_DESCRIPTION, regex("[[:digit:]]{4} -"))) %>%
  mutate(
    NUMBER = stri_extract_first(NUMBER_DESCRIPTION, regex = "\\w+"),
    DESCRIPTION = stri_extract_first(NUMBER_DESCRIPTION, regex = "\\s(.*)")
  )

extra_revenue_numbers <- c("0000") %>%
  as.character() %>%
  enframe(name = NULL) %>%
  rename("NUMBER" = "value") %>%
  mutate(
    "DESCRIPTION" =
      case_when(NUMBER == "0000" ~ "TEMPORARY HOLDER - ALEX NIELSON",),
    "NUMBER_DESCRIPTION" = paste(NUMBER, DESCRIPTION)
  )

lea_ucoa_revenue_classification <-
  lea_ucoa_revenue_classification %>%
  bind_rows(extra_revenue_numbers)


#consolidate ===================================================================
lea_ucoa_lookup <- list(
  fund                   = lea_ucoa_fund,
  location               = lea_ucoa_location,
  program                = lea_ucoa_program,
  funct                  = lea_ucoa_function,
  object                 = lea_ucoa_object,
  revenue_classification = lea_ucoa_revenue_classification
)
```
Remove unneeded objects
```{r}
rm(
  lea_ucoa_fund,
  lea_ucoa_location,
  lea_ucoa_function,
  lea_ucoa_program,
  lea_ucoa_revenue_classification,
  lea_ucoa_object,
  extra_program_numbers,
  extra_fund_numbers
)
```



#IV. Load and Validate UCOA codes
 *We will vadidate the code to remove missing values, and "". Then generate for three main reports. The first report contains both invalid LEA and NON-LEA codes. THe second report will be valid LEA codes (lea_reported_ucoa). The third report will be valid NON-LEA codes (I call it osa_reported_ucoa)

##Query AWS transaction table
```{r}

# Query the database, get all the records that are not obviously missing data. 
reported_ucoa <-
dbGetQuery(
  odbc_aws,
  paste("
        SELECT id, 
        batch_id,
        amount,
        fiscal_year,
        account_number,
        type
        FROM transaction
        WHERE account_number IS NOT NULL
        LIMIT 5000000")) %>% # note I am limitingto 10000000 so it doesn't take an eternity.
as_tibble() 

# double check for NA or "" ----------------------------------------------------

invalid_reported_na_or_empty <- reported_ucoa %>%
  filter(account_number=="",
        is.na(account_number))

reported_ucoa <- 
  reported_ucoa %>% 
  filter(account_number != "", !is.na(account_number))

#check correct length ----------------------------------------------------------

# 19 is for normal, 25 is for LEA. (dashes are included in string legth)
invalid_ucoa_length <- reported_ucoa %>% 
  filter(nchar(account_number) != 19 && nchar(account_number)!= 25) %>% 
  mutate(account_number_length = nchar(account_number),
         reason = case_when(account_number_length < 19 ~ "uca code too short for non LEA",
                            account_number_length > 19 & account_number_length<25 ~ "uca code incorrect length",
                            account_number_length > 25 ~ "uca code too long for LEA"))

reported_ucoa <- reported_ucoa %>% 
  filter(nchar(account_number) == 19 || nchar(account_number)== 25)


# Generate temp tibbles --------------------------------------------------------
# this will help with the subsequent reports. You could condense this, but for
# my mind this is easier to debugg and catch flaws. 

#filter for only lea
lea_reported_ucoa <- reported_ucoa %>% filter(nchar(account_number)== 25)

#filter for non lea
osa_reported_ucoa <- reported_ucoa %>% filter(nchar(account_number)== 19)

# lea ==========================================================================

# check if the codes are valid form. ie: ##-###-####-####-###-#### 
 
invalid_lea_ucoa_code <-
  lea_reported_ucoa %>%
  filter(!str_detect(
    lea_reported_ucoa$account_number,
    regex(
      "^[:digit:]{2}-[:alnum:]{3}-[:digit:]{4}-[:digit:]{4}-[:digit:]{3}-[:digit:]{4}$"
    )
  ))

lea_reported_ucoa <-
  lea_reported_ucoa %>%
  filter(str_detect(
    lea_reported_ucoa$account_number,
    regex(
      "^[:digit:]{2}-[:alnum:]{3}-[:digit:]{4}-[:digit:]{4}-[:digit:]{3}-[:digit:]{4}$"
    )
  ))

# non lea ====================================================================== 

# check if the codes are valid form. ie: ###-######-########  

invalid_osa_ucoa_codes <- osa_reported_ucoa %>%
  filter(!str_detect(
    osa_reported_ucoa$account_number,
    regex("^[:digit:]{3}-[:digit:]{6}-[:digit:]{8}$")
  ))

osa_reported_ucoa <-
  osa_reported_ucoa %>%
  filter(str_detect(
    osa_reported_ucoa$account_number,
    regex("^[:digit:]{3}-[:digit:]{6}-[:digit:]{8}$")
  ))

# consolidate ==================================================================
osa_ucoa <- osa_reported_ucoa
lea_ucoa <- lea_reported_ucoa
invalid_tables <-
  list(invalid_reported_na_or_empty,
       invalid_ucoa_length,
       invalid_lea_ucoa_code,
       invalid_osa_ucoa_codes)
names(invalid_tables) <- c("na_or_empty",
                           "invalid_length",
                           "invalid_lea_format",
                           "invalid_osa_format")

# remove unneeded objects ======================================================
# comment any object that you want to inspect in the global environment pane
rm(
  invalid_reported_na_or_empty,
  invalid_lea_ucoa_code,
  invalid_osa_ucoa_codes,
  invalid_ucoa_length,
  osa_reported_ucoa,
  lea_reported_ucoa,
  reported_ucoa
)
  
```

##OSA ucoa

### Enrich OSA ucoa tibble 
```{r}
# This breaks out the account numbers into fund, function, and account. 
osa_ucoa <- osa_ucoa %>% 
  mutate(
    fund = .[["account_number"]] %>% substr(0, 3),
    funct = .[["account_number"]] %>% substr(5, 10),
    account = .[["account_number"]] %>%  substr(12, 19),
  ) %>% 

# Now we need to join ucoa.xlsx, so we know what the codes mean.

# join the funds
left_join(ucoa_lookup[["fund"]] %>%
            as_tibble() %>%
            select(NUMBER, fund_description =`FULL DESCRIPTION`),
          by = c("fund"="NUMBER")
          ) %>% 
# join the functions
left_join(ucoa_lookup[["funct"]] %>%
            as_tibble() %>%
            select(NUMBER, function_description = `FULL DESCRIPTION`),
          by = c("funct" = "NUMBER")
          ) %>% 
# join the accounts
left_join(ucoa_lookup[["account"]] %>% 
            as_tibble() %>% 
            select(NUMBER, account_description = `FULL DESCRIPTION`),
          by = c("account" = "NUMBER")
          )
```
### Find unmapped OSA UCA 
*There are many reasons why this might be the case 
**They are using an old UCOA
**They pressed the incorrect key / typos
...regardless, they must be filtered out. 

```{r}
#find wrong fund code
osa_bad_fund_code <- osa_ucoa %>%
  filter(!fund %in% (ucoa_lookup %>%
                       pluck("fund")  %>%
                       select(NUMBER) %>%
                       unlist()))
#find wrong function code
osa_bad_funct_code<-osa_ucoa %>%
  filter(!funct %in% (ucoa_lookup %>%
                        pluck("funct") %>%
                        select(NUMBER) %>%
                        unlist()))
#find wrong account code
osa_bad_account_code <- osa_ucoa %>%
  filter(!account %in% (ucoa_lookup %>%
                          pluck("account") %>%
                          select(NUMBER)   %>%
                          unlist()))


#now remove incorrectly mapped. we will save them to report, but do not want
#them in our analysis.
osa_ucoa<- osa_ucoa %>% 
  anti_join(osa_bad_fund_code, by = "id") %>% 
  anti_join(osa_bad_funct_code, by = "id") %>% 
  anti_join(osa_bad_account_code, by = "id")

#consolidate
osa_non_mapping <-
  list(osa_bad_fund_code, osa_bad_funct_code, osa_bad_account_code)

names(osa_non_mapping) <-
  c("unmapped_fund_code",
    "unmapped_funct_code",
    "unmapped_account_code")


#remove objects
rm(osa_bad_fund_code,osa_bad_funct_code,osa_bad_account_code)
```
add "osa_non_mapping" to the invalid tables list
```{r}
invalid_tables <- c(invalid_tables, osa_non_mapping)
```

##LEA ucoa

### Enrich LEA ucoa tibble
```{r}
# This breaks out the account numbers into fund, function, and account. 
lea_ucoa <- lea_ucoa %>% 
  mutate(
    fund                   = .[["account_number"]] %>% substr(0, 2),
    location               = .[["account_number"]] %>% substr(4, 6),
    program                = .[["account_number"]] %>%  substr(8, 11),
    funct                  = .[["account_number"]] %>%  substr(13, 16),
    object                 = .[["account_number"]] %>%  substr(18, 20),
    revenue_classification = .[["account_number"]] %>%  substr(22, 25),
  ) %>% 

# temp_lea_ucoa<- lea_ucoa %>% 
#   mutate(
#     fund                   = .[["account_number"]] %>% substr(0, 2),
#     location               = .[["account_number"]] %>% substr(4, 6),
#     program                = .[["account_number"]] %>%  substr(8, 11),
#     funct                  = .[["account_number"]] %>%  substr(13, 16),
#     object                 = .[["account_number"]] %>%  substr(18, 20),
#     revenue_classification = .[["account_number"]] %>%  substr(22, 25),
#   ) %>% 
# Now we need to join ucoa.xlsx, so we know what the codes mean.

# join the funds
left_join(lea_ucoa_lookup %>%
            pluck("fund") %>%
            select(NUMBER, fund_description =`DESCRIPTION`),
          by = c("fund"="NUMBER")
          ) %>%
# join the functions
left_join(lea_ucoa_lookup %>%
            pluck("location") %>%
            select(NUMBER, location_description = `DESCRIPTION`),
          by = c("location" = "NUMBER")
          ) %>% 
# join the accounts
left_join(lea_ucoa_lookup %>% 
            pluck("program") %>% 
            select(NUMBER, program_description = `DESCRIPTION`),
          by = c("program" = "NUMBER")
          ) %>% 
left_join(lea_ucoa_lookup %>% 
            pluck("funct") %>%
          select(NUMBER, function_description = `DESCRIPTION`),
        by = c("funct" = "NUMBER")
        ) %>% 
left_join(lea_ucoa_lookup %>% 
            pluck("object") %>%
            select(NUMBER, object_description = `DESCRIPTION`),
          by = c("object" = "NUMBER")
          ) %>% 
left_join(lea_ucoa_lookup %>% 
            pluck("revenue_classification") %>%
            select(NUMBER, rev_class_description = `DESCRIPTION`),
          by = c("revenue_classification" = "NUMBER")
          )
```

### Find unmapped LEA UCA
*There are many reasons why this might be the case 
**They are using an old UCOA
**They pressed the incorrect key / typos
...regardless, they must be filtered out. 

```{r}
#find wrong fund code
lea_bad_fund_code <- lea_ucoa %>%
  filter(!fund %in% (lea_ucoa_lookup %>%
                       pluck("fund")  %>%
                       select(NUMBER) %>%
                       unlist()))

#find wrong location code
lea_bad_location_code<-lea_ucoa %>%
  filter(!location %in% (lea_ucoa_lookup %>%
                        pluck("location") %>%
                        select(NUMBER) %>%
                        unlist()))
#find wrong program code
lea_bad_program_code <- lea_ucoa %>%
  filter(!program %in% (lea_ucoa_lookup %>%
                          pluck("program") %>%
                          select(NUMBER)   %>%
                          unlist()))

lea_bad_funct_code <- lea_ucoa %>%
  filter(!funct %in% (lea_ucoa_lookup %>%
                          pluck("funct") %>%
                          select(NUMBER)   %>%
                          unlist()))

lea_bad_object_code <- lea_ucoa %>%
  filter(!object %in% (lea_ucoa_lookup %>%
                          pluck("object") %>%
                          select(NUMBER)   %>%
                          unlist()))

lea_bad_revenue_classification_code <- lea_ucoa %>%
  filter(!revenue_classification %in% (lea_ucoa_lookup %>%
                          pluck("revenue_classification") %>%
                          select(NUMBER)   %>%
                          unlist()))

#Remove invalid codes.
lea_ucoa<- lea_ucoa %>%
  anti_join(lea_bad_fund_code, by = "id") %>%
  anti_join(lea_bad_location_code, by = "id") %>%
  anti_join(lea_bad_program_code, by = "id") %>%
  anti_join(lea_bad_funct_code, by = "id") %>%
  anti_join(lea_bad_object_code, by = "id") %>%
  anti_join(lea_bad_revenue_classification_code, by = "id")

#consolidate
lea_non_mapping <-
  list(
    lea_bad_fund_code,
    lea_bad_location_code,
    lea_bad_program_code,
    lea_bad_funct_code,
    lea_bad_object_code,
    lea_bad_revenue_classification_code
  )
names(lea_non_mapping) <-
  c(
    "lea_unmapped_fund_code",
    "lea_unmapped_location_code",
    "lea_unmapped_program_code",
    "lea_unmapped_funct_code",
    "lea_unmapped_object_code",
    "lea_unmapped_revenue_classification_code"
  )
```

Remove uneeded objects
```{r}
rm(lea_bad_fund_code,
    lea_bad_location_code,
    lea_bad_program_code,
    lea_bad_funct_code,
    lea_bad_object_code,
    lea_bad_revenue_classification_code)
```

```{r}
invalid_tables <- c(invalid_tables, lea_non_mapping)
rm(lea_non_mapping)
```

### check for invalid header use 
```{r}
#https://www.schools.utah.gov/file/348f9876-ffcb-4c20-9802-dbc362bbb795
invalid_fund_code <-
  tibble(
    NUMBER = c(70),
    DESCRIPTION = c("Trust and Agency Funds (Header only, do not use) ")
  ) %>%
  mutate(NUMBER = as.character(NUMBER))

invalid_funct_code <-
  tibble(
    NUMBER = c(2000),
    DESCRIPTION = c("Support Services (Header Only – Do Not Use.)")
  ) %>%
  mutate(NUMBER = as.character(NUMBER))

#https://www.schools.utah.gov/file/21241526-8aee-4c36-9005-9e2122c7d98e
invalid_object_code <- tibble(
  NUMBER = c(
    100,
    110,
    120,
    130,
    140,
    150,
    160,
    170,
    180,
    190,
    200,
    300,
    400,
    500,
    600,
    700,
    800
  ),
  DESCRIPTION = c(
    "Salaries (Header Only - Do Not Use.)",
    "General District Administrative Salaries. (Header Only - Do Not Use.)",
    "School Administrative Salaries. (Header Only - Do Not Use.) ",
    "Instructional Salaries. (Header Only - Do Not Use.) ",
    "Licensed Non-Instructional Salaries. (Header Only - Do Not Use.)",
    "Office Salaries. (Header Only - Do Not Use.)",
    "Non-Licensed Instructional Salaries. (Header Only - Do Not Use.)",
    "Student Transportation Salaries. (Header Only - Do Not Use.)",
    "Operation and Maintenance Salaries. (Header Only - Do Not Use.)",
    "Other Salaries. (Header Only - Do Not Use.) ",
    "Employee Benefits. (Header Only – Do Not Use.)",
    "Purchased Professional and Technical Services (Header Only – Do Not Use.)",
    "Purchased Property Services (Header Only – Do Not Use.)",
    "Other Purchased Services (Header Only – Do Not Use.)",
    "Supplies and Materials (Header Only – Do Not Use.)",
    "Property (Header Only – Do Not Use.)",
    "Debt Service and Miscellaneous (Header Only – Do Not Use.) "
  )
) %>% mutate(NUMBER = as.character(NUMBER))

#https://www.schools.utah.gov/file/af07fab8-d759-4400-88e8-64566008f1ed
invalid_revenue_code <- tibble(
  NUMBER = c(
    1000,
    1100,
    1154,
    1300,
    1400,
    1500,
    1600,
    1700,
    1900,
    3000,
    4000,
    4530,
    5000
  ),
  DESCRIPTION = c(
    "Revenue from Local Sources (Header Only – Do Not Use.)",
    "Property Taxes (Header Only – Do Not Use.)",
    "Fee-in-Lieu of Taxes (FILT) (Header Only – Do Not Use.)",
    "Tuitions (Header Only – Do Not Use.)",
    "Transportation Fees (Header Only – Do Not Use.)",
    "Earnings on Investments (Header Only – Do Not Use.)",
    "Food Services (Header Only – Do Not Use.)",
    "Student Activities (Co-Curricular & Extra-Curricular) (Header Only – Do Not Use.)",
    "Other Revenue from Local Sources (Header Only – Do Not Use.) ",
    "Revenue from State Sources (Header Only – Do Not Use.)",
    "Revenue from Federal Sources (Header Only – Do Not Use.)",
    "Federal Applied Technology Education Sources. (Header Only. Do - Not Use.)",
    "Other Sources & Changes (Header Only – Do Not Use.)"
  )
) %>% mutate(NUMBER = as.character(NUMBER))


lea_header_fund_code <- lea_ucoa %>%
  filter(fund %in% (invalid_fund_code %>%
                      select(NUMBER)   %>%
                      unlist())) %>%
  left_join(invalid_fund_code, by = c("fund" = "NUMBER"))

lea_header_funct_code <- lea_ucoa %>%
  filter(fund %in% (invalid_funct_code %>%
                      select(NUMBER)   %>%
                      unlist())) %>%
  left_join(invalid_fund_code, by = c("funct" = "NUMBER"))

lea_header_revenue_code <- lea_ucoa %>%
  filter(revenue_classification %in% (invalid_revenue_code %>%
                                        select(NUMBER)   %>%
                                        unlist())) %>%
  left_join(invalid_fund_code, by = c("revenue_classification" = "NUMBER"))

lea_header_object_code <- lea_ucoa %>%
  filter(object %in% (invalid_object_code %>%
                        select(NUMBER)   %>%
                        unlist())) %>%
  left_join(invalid_object_code, by = c("object" = "NUMBER"))

```


#V. Aggregate Tables

## Aggregate Tables for non-LEAs

### By Description and Code
```{r}
agg_fund_amount <- osa_ucoa %>%
  agg_dollars_and_records(fund_description, fund)

agg_function_amount <- osa_ucoa %>%
  agg_dollars_and_records(function_description,funct)

agg_account_amount <- osa_ucoa %>%
  agg_dollars_and_records(account_description,account)

agg_by_description_and_code<- list(agg_fund_amount,agg_function_amount,agg_account_amount)

names(agg_by_description_and_code) <- c("agg_fund", "agg_function", "agg_account")

rm(agg_fund_amount,agg_function_amount,agg_account_amount)
```

### By Description 
```{r}
agg_fund_amount <- osa_ucoa %>% agg_dollars_and_records(fund_description)
agg_function_amount <- osa_ucoa %>% agg_dollars_and_records(function_description)
agg_account_amount <- osa_ucoa %>% agg_dollars_and_records(account_description)

agg_by_description<- list(agg_fund_amount,agg_function_amount,agg_account_amount)

names(agg_by_description) <- c("agg_fund", "agg_function", "agg_account")

rm(agg_fund_amount,agg_function_amount,agg_account_amount)
```

### By Code
```{r}
agg_fund_amount <- osa_ucoa %>% agg_dollars_and_records( fund)
agg_function_amount <- osa_ucoa %>% agg_dollars_and_records(funct)
agg_account_amount <- osa_ucoa %>% agg_dollars_and_records(account)

agg_by_code<- list(agg_fund_amount,agg_function_amount,agg_account_amount)

names(agg_by_code) <- c("agg_fund", "agg_function", "agg_account")

rm(agg_fund_amount,agg_function_amount,agg_account_amount)
```

### Consolidate and Remove
```{r}
#consolidate into one list

osa_agg_tables <- list(agg_by_description_and_code, agg_by_description,agg_by_code)

names(osa_agg_tables) <- c("agg_by_description_and_code",
                           "agg_by_description",
                           "agg_by_code")
#delete objects
rm(agg_by_description_and_code,agg_by_description,agg_by_code)
```



## Aggregate Tables for LEAs

### By Description and Code
```{r}
agg_fund_amount <- lea_ucoa %>%
  agg_dollars_and_records(fund_description, fund)
agg_location_amount <- lea_ucoa %>%
  agg_dollars_and_records(location_description, location)
agg_program_amount <- lea_ucoa %>%
  agg_dollars_and_records(program_description, program)
agg_funct_amount <- lea_ucoa %>%
  agg_dollars_and_records(funct_description, funct)
agg_object_amount <- lea_ucoa %>%
  agg_dollars_and_records(object_description, object)
agg_rev_class_amount <- lea_ucoa %>%
  agg_dollars_and_records(rev_class_description, revenue_classification)

agg_by_description_and_code <-
  list(
    agg_fund_amount,
    agg_location_amount,
    agg_program_amount,
    agg_function_amount,
    agg_object_amount,
    agg_rev_class_amount
  )

names(agg_by_description_and_code) <-
  c(
    "agg_fund",
    "agg_location",
    "agg_program",
    "agg_function",
    "agg_object",
    "agg_revenue_classification"
  )

rm(
  agg_fund_amount,
  agg_location_amount,
  agg_program_amount,
  agg_function_amount,
  agg_object_amount,
  agg_rev_class_amount
)
```

### By Description only
```{r}
agg_fund_amount <- lea_ucoa %>%
  agg_dollars_and_records(fund_description)
agg_location_amount <- lea_ucoa %>%
  agg_dollars_and_records(location_description)
agg_program_amount <- lea_ucoa %>%
  agg_dollars_and_records(program_description)
agg_funct_amount <- lea_ucoa %>%
  agg_dollars_and_records(funct_description)
agg_object_amount <- lea_ucoa %>%
  agg_dollars_and_records(object_description)
agg_rev_class_amount <- lea_ucoa %>%
  agg_dollars_and_records(rev_class_description)

agg_by_description <-
  list(
    agg_fund_amount,
    agg_location_amount,
    agg_program_amount,
    agg_function_amount,
    agg_object_amount,
    agg_rev_class_amount
  )

names(agg_by_description) <-
  c(
    "agg_fund",
    "agg_location",
    "agg_program",
    "agg_function",
    "agg_object",
    "agg_revenue_classification"
  )

rm(
  agg_fund_amount,
  agg_location_amount,
  agg_program_amount,
  agg_function_amount,
  agg_object_amount,
  agg_rev_class_amount
)
```

### By Code only
```{r}
agg_fund_amount <- lea_ucoa %>%
  agg_dollars_and_records(fund)
agg_location_amount <- lea_ucoa %>%
  agg_dollars_and_records(location)
agg_program_amount <- lea_ucoa %>%
  agg_dollars_and_records(program)
agg_funct_amount <- lea_ucoa %>%
  agg_dollars_and_records(funct)
agg_object_amount <- lea_ucoa %>%
  agg_dollars_and_records(object)
agg_rev_class_amount <- lea_ucoa %>%
  agg_dollars_and_records(revenue_classification)

agg_by_code <-
  list(
    agg_fund_amount,
    agg_location_amount,
    agg_program_amount,
    agg_function_amount,
    agg_object_amount,
    agg_rev_class_amount
  )

names(agg_by_code) <-
  c(
    "agg_fund",
    "agg_location",
    "agg_program",
    "agg_function",
    "agg_object",
    "agg_revenue_classification"
  )

rm(
  agg_fund_amount,
  agg_location_amount,
  agg_program_amount,
  agg_function_amount,
  agg_object_amount,
  agg_rev_class_amount
)
```

```{r}
lea_agg_tables <-
  list(agg_by_description_and_code, agg_by_description, agg_by_code)

names(lea_agg_tables) <-
  c("agg_by_description_and_code",
    "agg_by_description",
    "agg_by_code")

rm(agg_by_description_and_code, agg_by_description, agg_by_code)
```



#VI. Visualizations

## visualizae non LEA aggregate tables

### Visualizing the the "Fund" category
```{r}
#create a simple barplot to show the different types of ucoa codes for funds only

agg_fund_plot <-  osa_agg_tables %>%
  pluck("agg_by_description") %>%
  pluck("agg_fund") %>% 
  ggplot(aes(x = fund_description, y = total_amount)) + geom_bar(stat = "identity", fill = "lightcoral") +
  coord_flip() +
  geom_text(
    aes(label = paste0("$", total_amount)),
    hjust = -.25,
    vjust = 0,
    size = 2
  ) +
  labs(title = "Barplot of Cumulative Net Amount ($) by Description",
       x = "Description of Fund",
       y = "Cumulative Net Amount ($)")

agg_fund_plot
```


###visualizing the "Function" category
```{r}

```


### visualize the "Account" category


```{r}
barplot_amount <- function(templist,agg_by_type, agg_type, uca_block, temprange){
  # Description
  # 
  # Inputs: templist (list):
  #         agg_by_type(string/char):  used to decide whether to pluck by_description_and_code, by_description, or by_code
  #         agg_type(string/char): used to pluck a specific type of aggregat table such as agg_fund or agg_function
  #         uca_block(object?): the uca block of interest, ex: fund, location, object...
  #         temprange(int): a range of interest. for example : 4000 ==> 40000000
  # 
  # Outputs:
  #         p (ggplot object)
  
  uca_block <-enquo(uca_block)
  
  p <- templist %>%
    pluck(agg_by_type) %>%
    pluck(agg_type) %>%
    filter(str_detect(!!uca_block, paste0("^", temprange))) %>%
    ggplot(aes(x = !!uca_block, y = total_amount)) +
    geom_bar(stat = "identity", fill = "lightcoral") +
    coord_flip() +
    geom_text(
      aes(label = paste0("$", total_amount)),
      hjust = "inward",#-.25,
      vjust = "inwward",#0,
      size = 3
    ) +
    labs(title = paste0(
      "barplot of ",
      rlang::as_name(uca_block),
      " in range: ",
      temprange,
      "0000"
    ))
  p

}

```

```{r}
test<- barplot_amount(templist = osa_agg_tables,
               agg_by_type= "agg_by_code",
               agg_type = "agg_account",
               uca_block = account,
               temprange = 3001)
```


#### visualize revenue by code
```{r}

#make plots by revenues ========================================================
temp_sequence_revenues <- seq(from = 3000, to = 3009,  by = 1)

revenue_plots<- temp_sequence_revenues %>%
  map(
    barplot_amount,
    templist = osa_agg_tables,
    agg_by_type= "agg_by_code",
    agg_type = "agg_account",
    uca_block = account
  )

names(revenue_plots) <- c("revenues",
                  "taxes",
                  "licenses_and_permits",
                  "intergovernmental",
                  "charges_for_service",
                  "fines_and_forfeitures",
                  "miscellaneous",
                  "other_sources_of_funding",
                  "special_and_extraordinary_gain",
                  "suspense")

#Make plots for expenditures ===================================================
temp_sequence_expenditures <- seq(from = 4000, to = 4017,  by=1)

expenditure_plots<- temp_sequence_expenditures %>%
  map(
    barplot_amount,
    templist = osa_agg_tables,
    agg_by_type= "agg_by_code",
    agg_type = "agg_account",
    uca_block = account
  )
names(expenditure_plots) <- c("expenditures",
                  "personnel_services",
                  "general_and_contracted_services",
                  "utilities_and_utility_services",
                  "taxes_and_fees",
                  "supplies_and_materials",
                  "grants_and_contracts",
                  "direct_payments",
                  "capital_outlays",
                  "interdepartmental_charges",
                  "judgements_and_losses",
                  "other_financing_uses",
                  "depreciation",
                  "amortiaton",
                  "bad_debt_expense",
                  "contingencies",
                  "special_and_extraordinary_loss",
                  "debt_service")

#consolidate objects
account_plots <- list(revenue_plots, expenditure_plots)
names(account_plots) <- c("revenue_plots", "expenditure_plots")

#remove redundant objects
rm(temp_sequence_revenues, temp_sequence_expenditures, revenue_plots, expenditure_plots)
```
##### view the plots
```{r}
#to see all plot simply run:
account_plots



```
To only view the revenue plots, we pluck it from the list.
```{r}
temp <- account_plots %>% pluck("revenue_plots") 
temp
```
If you are only interested in one plot, use the following code
```{r}
temp <- account_plots %>% 
  pluck("expenditure_plots") %>% 
  pluck("capital_outlays")
temp
```


To access elements of the plot, use this code format. The code below selects the data frame used to generate the plot from 
```{r}
temp_zoom <- account_plots %>% 
  pluck("revenue_plots") %>%
  pluck("intergovernmental") %>%
  pluck("data")
```

```{r}
#get rid of temp_zoom
rm(temp_zoom)
```


#### visualize revenue by description
 if the data is properly cleaned then this chunk is redundant. 
```{r}


plot_in_range <- function(temp_range){
  
  p <- osa_agg_tables %>% 
      pluck("agg_by_description_and_code") %>% 
      pluck("agg_account") %>% 
      filter(str_detect(account, paste0("^",temp_range))) %>% #only selects taxes
      ggplot(aes(x=account_description, y=total_amount))+ geom_bar(stat = "identity", fill = "lightcoral")+
      coord_flip()+
      geom_text(aes(label=paste0("$",total_amount)), hjust = -.25,vjust=0, size=3)+
      labs(title = paste0("Barplot of Account Revenues in Range: ", temp_range,"0000") )
  p
  
}

temp_sequence_revenues <- seq(from = 3000, to = 3009,  by=1)

revenue_plots<- temp_sequence_revenues %>% map(plot_in_range)
names(revenue_plots) <- c("revenues",
                  "taxes",
                  "licenses_and_permits",
                  "intergovernmental",
                  "charges_for_service",
                  "fines_and_forfeitures",
                  "miscellaneous",
                  "other_sources_of_funding",
                  "special_and_extraordinary_gain",
                  "suspense")

temp_sequence_expenditures <- seq(from = 4000, to = 4017,  by=1)

expenditure_plots<- temp_sequence_expenditures %>% map(plot_in_range)
names(expenditure_plots) <- c("expenditures",
                  "personnel_services",
                  "general_and_contracted_services",
                  "utilities_and_utility_services",
                  "taxes_and_fees",
                  "supplies_and_materials",
                  "grants_and_contracts",
                  "direct_payments",
                  "capital_outlays",
                  "interdepartmental_charges",
                  "judgements_and_losses",
                  "other_financing_uses",
                  "depreciation",
                  "amortiaton",
                  "bad_debt_expense",
                  "contingencies",
                  "special_and_extraordinary_loss",
                  "debt_service")

#consolidate objects
account_plots <- list(revenue_plots, expenditure_plots)
names(account_plots) <- c("revenue_plots", "expenditure_plots")

#remove redundant objects
rm(temp_sequence_revenues, temp_sequence_expenditures, revenue_plots, expenditure_plots)
```

```{r}
account_plots %>% pluck("revenue_plots")
```


You can access plot elements to quickly zoom in on the data. for example:
```{r}
#temp_zoom <- plots %>% pluck("intergovernmental") %>% pluck("data")
```



##Visualize LEA aggregate tables

### Fund
```{r}
agg_fund_plot <-  lea_agg_tables %>%
  pluck("agg_by_description_and_code") %>%
  pluck("agg_fund") %>% 
  ggplot(aes(x = fund_description, y = total_amount)) + geom_bar(stat = "identity", fill = "lightcoral") +
  coord_flip() +
  geom_text(
    aes(label = paste0("$", total_amount)),
    hjust = -.25,
    vjust = 0,
    size = 2
  ) +
  labs(title = "Barplot of Cumulative Net Amount ($) by Description",
       x = "Description of Fund",
       y = "Cumulative Net Amount ($)")

agg_fund_plot
```







#VII. Generate Invalid Report

## na_or_empty : Examine transactions with na or empty value for their account number
```{r}
invalid_tables %>% pluck("na_or_empty")
```

## invalid_length : Examine transactions with an account number too long or too small to fit either LEA or non-LEA UCOA.
```{r}
invalid_tables %>% pluck("invalid_length")
```

## invalid_lea_format : Examine transactions for LEAs with an account number with correct length, but incorrect format
```{r}
invalid_tables %>% pluck("invalid_lea_format")
```


## invalid_osa_format : Examine transactions for non LEAs with an account number with correct length, but incorrect format
```{r}
invalid_tables %>% pluck("invalid_osa_format")
```

## Unmapped codes
  * Note that for all, you can view more information. The data in each table is as follows:
    **id
    **batch_id
    **amount 
    **fiscal_year
    **account_number
    **type
    **fund
    **funct
    **...
    **fund_description
    **function_description
    **...
### unmapped_fund_code : Examine transactions for non LEAs with an account number with correct length, and correct format, but the fund code provided does not map to the ucoa code spreadsheet
```{r}
invalid_tables %>% pluck("unmapped_fund_code") %>% select(id, batch_id, amount, fund, fund_description)
```


### unmapped_fund_code : Examine transactions for non LEAs with an account number with correct length, and correct format, but the function code provided does not map to the ucoa code spreadsheet
```{r}
invalid_tables %>% pluck("unmapped_funct_code") %>% select(id, batch_id, amount, funct, function_description)
```
### unmapped_account_code : Examine transactions for non LEAs with an account number with correct length, and correct format, but the account code provided does not map to the ucoa code spreadsheet
```{r}
invalid_tables %>% pluck("unmapped_account_code") %>% select(id, batch_id, amount, account, account_description)
```

### lea_unmapped_fund_code : Examine transactions for non LEAs with an account number with correct length, and correct format, but the account code provided does not map to the ucoa code spreadsheet

```{r}
invalid_tables %>% pluck("lea_unmapped_fund_code") %>% select(id, batch_id, amount, fund, fund_description)
```

### lea_unmapped_location_code : Examine transactions for non LEAs with an account number with correct length, and correct format, but the account code provided does not map to the ucoa code spreadsheet

```{r}
invalid_tables %>% pluck("lea_unmapped_location_code") %>% select(id, batch_id, amount, location, location_description)
```

### lea_unmapped_program_code : Examine transactions for non LEAs with an account number with correct length, and correct format, but the account code provided does not map to the ucoa code spreadsheet

```{r}
invalid_tables %>% pluck("lea_unmapped_program_code") %>% select(id, batch_id, amount, program, program_description)
```

### lea_unmapped_funct_code : Examine transactions for non LEAs with an account number with correct length, and correct format, but the account code provided does not map to the ucoa code spreadsheet

```{r}
invalid_tables %>% pluck("lea_unmapped_funct_code") %>% select(id, batch_id, amount, funct, function_description)
```

### lea_unmapped_object_code : Examine transactions for non LEAs with an account number with correct length, and correct format, but the account code provided does not map to the ucoa code spreadsheet

```{r}
invalid_tables %>% pluck("lea_unmapped_object_code") %>% select(id, batch_id, amount, object, object_description)
```

### lea_unmapped_revenue_classification_code : Examine transactions for non LEAs with an account number with correct length, and correct format, but the account code provided does not map to the ucoa code spreadsheet

```{r}
invalid_tables %>% pluck("lea_unmapped_revenue_classification_code") %>% select(id, batch_id, amount, revenue_classification, rev_class_description)
```


