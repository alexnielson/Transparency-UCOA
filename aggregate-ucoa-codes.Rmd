# 0. Program Description

**Purpose**
I am interested in learning more about how to access and pay with the UCOA codes. I decided to conduct some Exploratory Data Analysis in this document as well. This script is not really meant for a single button run-all. It rather is built to allow a data analyst to play around with the data easily. It does contain a few basic reports and interesting plots. 

DURATION: the script will take about 20-30 minutes to run.

**Input(s)**

```{r}
dsn_aws        <- "transpAWS"
dsn_salesforce <- "salesforce"
```

**Output(s)**


# I. Libraries and Data Sources

```{r}
library(lubridate)
library(magrittr)
library(odbc)
library(readxl) 
library(tidyverse)

odbc_aws <- dbConnect(odbc::odbc(), dsn_aws)
odbc_sf  <- dbConnect(odbc::odbc(), dsn_salesforce)

rm(dsn_aws, dsn_salesforce)

download.file(
  "http://financialreports.utah.gov/chartofaccounts/ChartofAccountFull.xlsx",
  "ucoa.xlsx",
  mode = "wb")
```


# II.Function Definitions

DONT FORGET TO ADD ALL OF THESE LATER...

# III. Execution

## Salesforce

Query Salesforce. 
```{r}
# Note that I do not query LEAs. They are managed by USBE, which uses a
# different chart of accounts. I also do not query higher education.

sf_data <-
  dbGetQuery(
    odbc_sf,
    paste("
          SELECT
            Account.Name                  AS name,
            Account.Id                    AS id,
            Account.Transparency_ID__c    AS t_id,
            Account.Fiscal_Year_Begins__c AS begin_fy,
            RecordType.DeveloperName      AS govt_type
          FROM Account
          JOIN RecordType
          ON Account.RecordTypeId = RecordType.Id
          WHERE Account.RecordTypeId IN (
            SELECT Id
            FROM RecordType
            WHERE DeveloperName IN (
            'AOG',
            'City',
            'Conservation_District',
            'County',
            'District_Health',
            'Housing',
            'Independent_Quasi_State_Entity',
            'Interlocal',
            'Local_and_Special_Service_District',
            'Mental_Health',
            'Redevelopment_Agency_Project_Area',
            'Town'))
          AND Account.Entity_Status__c IN (
            'Current',
            'On hold',
            'Delinquent',
            'Suspended')
          AND Account.Name NOT IN (
            'Intermountain Power Agency',
            'Utah Associated Municipal Power Systems',
            'Utah Municipal Power Agency')
          AND (
            Account.Expense_Revenue_Start_Date__c <= DATE() OR
            Account.Expense_Revenue_Start_Date__c IS NULL)")) %>%
  as_tibble()
```

## UCOA

```{r}
#note that excel_sheets() returns a list, hence the list access syntax.
#access in this way since it is a xlsx file.
ucoa_fund <- 
  read_xlsx("ucoa.xlsx", sheet = excel_sheets("ucoa.xlsx")[[1]] )

ucoa_function <- 
  read_xlsx("ucoa.xlsx", sheet = excel_sheets("ucoa.xlsx")[[2]] )

ucoa_account <- 
  read_xlsx("ucoa.xlsx", sheet = excel_sheets("ucoa.xlsx")[[3]] )

#Since the xlsx file was built to be readable, and not necessarily easily
#parsed, the first two rows must be cleaned. 

#fix the column names
colnames(ucoa_fund)     <- ucoa_fund[2, ]
colnames(ucoa_function) <- c("NUMBER", ucoa_function[1, 2:4])
colnames(ucoa_account)  <- ucoa_account[2, ]

#remove the useless rows.
ucoa_fund     <- ucoa_fund     %>% slice(-1, -2)
ucoa_function <- ucoa_function %>% slice(-1)
ucoa_account  <- ucoa_account  %>% slice(-1, -2)


extra_fund_numbers <-
  c(201:299, 301:399, 401:449, 451:499, 501:599, 601:699, 701:799) %>%
  as.character() %>%
  enframe(name = NULL) %>%
  rename("NUMBER" = "value") %>%
  mutate("SHORT DESCRIPTION" = NA,
         `FULL DESCRIPTION` = case_when(
            NUMBER %in% (201:299) ~ "Special Revenue Funds (as assigned by local government)",
            NUMBER %in% (301:399) ~ "Debt Service Funds (as assigned by local government)",
            NUMBER %in% (401:449) ~ "Capital Projects Funds (as assigned by local government)",
            NUMBER %in% (451:499) ~ "Permanent Funds (as assigned by local government)",
            NUMBER %in% (501:599) ~ "Enterprise Funds (as assigned by local government)",
            NUMBER %in% (601:699) ~ "Internal Service Funds (as assigned by local government)",
            NUMBER %in% (701:799) ~ "Trust and Agency Funds (as assigned by local government)"
                                        ),
         "DETAIL" = NA
    
         )

ucoa_fund <-
  ucoa_fund %>%
  bind_rows(extra_fund_numbers)

#fix some other random formattings. ie: 10 ==> 010

ucoa_fund$NUMBER[[1]]     <- "010"
ucoa_fund$NUMBER[[2]]     <- "020"
ucoa_fund$NUMBER[[3]]     <- "030"
ucoa_function$NUMBER[[1]] <- "000000"

#we want a table of just account expenditures
ucoa_account_exp <-
  ucoa_account %>% 
  filter(str_detect(NUMBER, "^4"))# filter for any row which starts with 4,
                                  # this is because UCoA attributes anything in 
                                  # the 3000-3999 to revenues

#we also want a table of just account revenues. 
ucoa_account_rev <- 
  ucoa_account %>% 
  filter(str_detect(NUMBER, "^3"))# filter for any row which starts with 3
                                  # this is because UCoA attribtes anything in
                                  # the 3000-3999 to revenues

#if we want a table of just w2 information, then we should run this code too.  
# ucoa_account_w2 <- 
#   ucoa_account %>% 
#   filter(str_detect(NUMBER, "^4001"))


ucoa_vague_funct <- 
  ucoa_function %>% 
  filter(                #DESCRIPTION OF FUNCTION
    NUMBER == "000000" | # Not Applicable
    NUMBER == "100000" | # General Government
    NUMBER == "200000" | # Public Safety
    NUMBER == "300000" | # Public Works
    NUMBER == "400000" | # Health
    NUMBER == "500000")  # Community

ucoa_vague_exp <- 
  ucoa_account_exp %>% 
  filter(                  # DESCRIPTION of Expeditures accounts
    NUMBER == "40000000" | # Expenditures
    NUMBER == "40010000" | # Personnel Services
    NUMBER == "40020000" | # General and Contracted Services
    NUMBER == "40030000" | # Utilities and Utility Services
    NUMBER == "40040000" | # Taxes and Fees
    NUMBER == "40050000" | # Supplies and Materials
    NUMBER == "40060000" | # Grants and Contracts
    NUMBER == "40070000" | # Direct Payments
    NUMBER == "40080000" | # Capital Outlays
      # Notice that I think that 40090000 Interdepartmental Charges, and
      # 40100000 Judgements and Losses are considered non-vague. Since they
      # cannot be broken down further. If this ever change then we would need to
      # include them here.
    NUMBER == "40110000" | # Other financing Uses
      # As noted above, 40120000:40160000 cannot be broken down into more
      # specific accounts
    NUMBER == "40170000" ) # Debt Service

ucoa_vague_rev <- 
  ucoa_account_rev %>% 
  filter(                  # DESCRIPTION OF Revenue accounts
    NUMBER == "30000000" | # Revenues
    NUMBER == "30010000" | # Taxes
    NUMBER == "30020000" | # Licenses and Permits
    NUMBER == "30030000" | # Intergovernmental
    NUMBER == "30040000" | # Charges For Service
    NUMBER == "30050000" | # Fines and Forfeitures
    NUMBER == "30060000" | # Miscellaneous
    NUMBER == "30070000" ) # Other Sources of Funding

ucoa <-
  list(
    fund        = ucoa_fund,
    funct       = ucoa_function,
    account     = ucoa_account,
    account_exp = ucoa_account_exp,
    account_rev = ucoa_account_rev,
    vague_funct = ucoa_vague_funct,
    vague_exp   = ucoa_vague_exp,
    vague_rev   = ucoa_vague_rev)

rm(ucoa_fund, ucoa_function, ucoa_account, extra_fund_numbers, ucoa_account_exp,
   ucoa_account_rev, ucoa_vague_funct, ucoa_vague_exp, ucoa_vague_rev)
```

## LEA UCOA
```{r}
#put code here to generate a useful lea ucoa. 
```


#IV. Load and Validate UCOA codes
 *We will vadidate the code to remove missing values, and "". Then generate for three main reports. The first report contains both invalid LEA and NON-LEA codes. THe second report will be valid LEA codes (lea_reported_ucoa). The third report will be valid NON-LEA codes (I call it osa_reported_ucoa)
```{r}

# Query the database, get all the records that are not obviously missing data. 
reported_ucoa <-
dbGetQuery(
  odbc_aws,
  paste("
        SELECT id, 
        batch_id,
        amount,
        fiscal_year,
        account_number,
        type
        FROM transaction
        WHERE account_number IS NOT NULL
        LIMIT 10000000")) %>% # note I am limitingto 10000000 so it doesn't take an eternity.
as_tibble() 

# double check for NA or "" ----------------------------------------------------

invalid_reported_na_or_empty <- reported_ucoa %>%
  filter(account_number=="",
        is.na(account_number))

reported_ucoa <- 
  reported_ucoa %>% 
  filter(account_number != "", !is.na(account_number))


#check correct length ----------------------------------------------------------

# 19 is for normal, 25 is for LEA. (dashes are included in string legth)
invalid_ucoa_length <- reported_ucoa %>% 
  filter(nchar(account_number) != 19 && !nchar(account_number)!= 25)

reported_ucoa <- reported_ucoa %>% 
  filter(nchar(account_number) == 19 || nchar(account_number)== 25)


# Generate temp tibbles --------------------------------------------------------
# this will help with the subsequent reports. You could condense this, but for
# my mind this is easier to debugg and catch flaws. 

#filter for only lea
lea_reported_ucoa <- reported_ucoa %>% filter(nchar(account_number)== 25)

#filter for non lea
osa_reported_ucoa <- reported_ucoa %>% filter(nchar(account_number)== 19)

# lea ==========================================================================

# check if the codes are valid form. ie: ##-###-####-####-###-#### 
 
invalid_lea_ucoa_code <-
  lea_reported_ucoa %>%
  filter(!str_detect(
    lea_reported_ucoa$account_number,
    regex(
      "^[:digit:]{2}-[:alnum:]{3}-[:digit:]{4}-[:digit:]{4}-[:digit:]{3}-[:digit:]{4}$"
    )
  ))

lea_reported_ucoa <-
  lea_reported_ucoa %>%
  filter(str_detect(
    lea_reported_ucoa$account_number,
    regex(
      "^[:digit:]{2}-[:alnum:]{3}-[:digit:]{4}-[:digit:]{4}-[:digit:]{3}-[:digit:]{4}$"
    )
  ))

# non lea ====================================================================== 

# check if the codes are valid form. ie: ###-######-########  

invalid_osa_ucoa_codes <- osa_reported_ucoa %>%
  filter(!str_detect(
    osa_reported_ucoa$account_number,
    regex("^[:digit:]{3}-[:digit:]{6}-[:digit:]{8}$")
  ))

osa_reported_ucoa <-
  osa_reported_ucoa %>%
  filter(str_detect(
    osa_reported_ucoa$account_number,
    regex("^[:digit:]{3}-[:digit:]{6}-[:digit:]{8}$")
  ))

# consolidate ==================================================================
osa_ucoa <- osa_reported_ucoa
lea_ucoa <- lea_reported_ucoa
invalid_tables <-
  list(invalid_reported_na_or_empty,
       invalid_ucoa_length,
       invalid_lea_ucoa_code,
       invalid_osa_ucoa_codes)
names(invalid_tables) <- c("na_or_empty",
                           "invalid_length",
                           "invalid_lea_format",
                           "invalid_osa_format")

# remove unneeded objects ======================================================
    # comment any object that you want to inspect in the global environment pane
rm(
  invalid_reported_na_or_empty,
  invalid_lea_ucoa_code,
  invalid_osa_ucoa_codes,
  invalid_ucoa_length,
  osa_reported_ucoa,
  lea_reported_ucoa,
  reported_ucoa
)
  
```

### Export the invalid tables
```{r}
#since the invalid tables is large list, we should export the invalid tables, and then remove that list. 
# Do this at the end, once we are done writing the program.
```


### Enrich non - LEA ucoa tibble 
```{r}
# This breaks out the account numbers into fund, function, and account. 
osa_ucoa <- osa_ucoa %>% 
  mutate(
    fund = .[["account_number"]] %>% substr(0, 3),
    funct = .[["account_number"]] %>% substr(5, 10),
    account = .[["account_number"]] %>%  substr(12, 19),
  ) %>% 

# Now we need to join ucoa.xlsx, so we know what the codes mean.

# join the funds
left_join(ucoa[["fund"]] %>%
            as_tibble() %>%
            select(NUMBER, fund_description =`FULL DESCRIPTION`),
          by = c("fund"="NUMBER")
          ) %>% 
# join the functions
left_join(ucoa[["funct"]] %>%
            as_tibble() %>%
            select(NUMBER, function_description = `FULL DESCRIPTION`),
          by = c("funct" = "NUMBER")
          ) %>% 
# join the accounts
left_join(ucoa[["account"]] %>% 
            as_tibble() %>% 
            select(NUMBER, account_description = `FULL DESCRIPTION`),
          by = c("account" = "NUMBER")
          )
```
#### Validate the codes

#### Find a list of entities who used codes which do no map to the UCA. 
*There are many reasons why this might be the case 
**They are using an old UCOA
**They pressed the incorrect key / typos

#regardless, they must be filtered out. 
```{r}
#find wrong fund code
osa_bad_fund_code <- osa_ucoa %>%
  filter(!fund %in% (ucoa %>%
                       pluck("fund")  %>%
                       select(NUMBER) %>%
                       unlist()))
#find wrong function code
osa_bad_funct_code<-osa_ucoa %>%
  filter(!funct %in% (ucoa %>%
                        pluck("funct") %>%
                        select(NUMBER) %>%
                        unlist()))
#find wrong account code
osa_bad_account_code <- osa_ucoa %>%
  filter(!account %in% (ucoa %>%
                          pluck("account") %>%
                          select(NUMBER)   %>%
                          unlist()))


#now remove incorrectly mapped. we will save them to report, but do not want them in our analysis.

osa_ucoa<- osa_ucoa %>% 
  anti_join(osa_bad_fund_code, by = "id") %>% 
  anti_join(osa_bad_funct_code, by = "id") %>% 
  anti_join(osa_bad_account_code, by = "id")



#consolidate
osa_non_mapping <- list(osa_bad_fund_code,osa_bad_funct_code,osa_bad_account_code)
names(osa_non_mapping) <- c("unmapped_fund_code","unmapped_funct_code","unmapped_account_code")


#remove objects
rm(osa_bad_fund_code,osa_bad_funct_code,osa_bad_account_code)
```
add "osa_non_mapping" to the invalid tables list
```{r}
invalid_tables <- c(invalid_tables, osa_non_mapping)
```


###enrich the LEA ucoa
```{r}
#put that code here.
```


#V. Aggregate Tables

## Aggregate Tables for non-LEAs

### Aggregate by descrition and number/code
```{r}


agg_fund_amount <-  osa_ucoa %>% 
  group_by(fund_description, fund) %>% 
  summarize(total_amount = sum(amount),
            num_of_trans = n() ) %>% 
  arrange(desc(total_amount))
  
agg_function_amount <-  osa_ucoa %>% 
  group_by(function_description, funct) %>% 
  summarize(total_amount = sum(amount),
            num_of_trans = n() ) %>% 
  arrange(desc(total_amount))

agg_account_amount <-  osa_ucoa %>% 
  group_by(account_description, account) %>% 
  summarize(total_amount = sum(amount),
            num_of_trans = n() ) %>% 
  arrange(desc(total_amount))


agg_by_description_and_code<- list(agg_fund_amount,agg_function_amount,agg_account_amount)
names(agg_by_description_and_code) <- c("agg_fund", "agg_function", "agg_account")

rm(agg_fund_amount,agg_function_amount,agg_account_amount)

```
*!NOTE: the next two aggregations are only useful if the data is not properly cleaned or entered. If every code has a mapped description, then only the above agg table is necessary.*

### Aggregate by description only
```{r}


agg_fund_amount <-  osa_ucoa %>% 
  group_by(fund_description) %>% 
  summarize(total_amount = sum(amount),
            num_of_trans = n() ) %>% 
  arrange(desc(total_amount))
  
agg_function_amount <-  osa_ucoa %>% 
  group_by(function_description) %>% 
  summarize(total_amount = sum(amount),
            num_of_trans = n() ) %>% 
  arrange(desc(total_amount))

agg_account_amount <-  osa_ucoa %>% 
  group_by(account_description) %>% 
  summarize(total_amount = sum(amount),
            num_of_trans = n() ) %>% 
  arrange(desc(total_amount))


agg_by_description<- list(agg_fund_amount,agg_function_amount,agg_account_amount)
names(agg_by_description) <- c("agg_fund", "agg_function", "agg_account")

rm(agg_fund_amount,agg_function_amount,agg_account_amount)

```

### Aggregate by Code
```{r}


agg_fund_amount <-  osa_ucoa %>% 
  group_by( fund) %>% 
  summarize(total_amount = sum(amount),
            num_of_trans = n() ) %>% 
  arrange(desc(total_amount))
  
agg_function_amount <-  osa_ucoa %>% 
  group_by(funct) %>% 
  summarize(total_amount = sum(amount),
            num_of_trans = n() ) %>% 
  arrange(desc(total_amount))

agg_account_amount <-  osa_ucoa %>% 
  group_by(account) %>% 
  summarize(total_amount = sum(amount),
            num_of_trans = n() ) %>% 
  arrange(desc(total_amount))


agg_by_code<- list(agg_fund_amount,agg_function_amount,agg_account_amount)
names(agg_by_code) <- c("agg_fund", "agg_function", "agg_account")

rm(agg_fund_amount,agg_function_amount,agg_account_amount)

```

```{r}
#consolidate into one list

osa_agg_tables <- list(agg_by_description_and_code, agg_by_description,agg_by_code)
names(osa_agg_tables) <- c("agg_by_description_and_code","agg_by_description", "agg_by_code")
rm(agg_by_description_and_code,agg_by_description,agg_by_code)
```










#VI. Visualizations

##visualizae aggregate tables

### Visualizing the the "Fund" category
```{r}
#create a simple barplot to show the different types of ucoa codes for funds only

agg_fund_plot <-  osa_agg_tables %>%
  pluck("agg_by_description") %>%
  pluck("agg_fund") %>%
  ggplot(aes(x = fund_description, y = total_amount)) + geom_bar(stat = "identity", fill = "lightcoral") +
  coord_flip() +
  geom_text(
    aes(label = paste0("$", total_amount)),
    hjust = -.25,
    vjust = 0,
    size = 2
  ) +
  labs(title = "Barplot of Cumulative Net Amount ($) by Description",
       x = "Description of Fund",
       y = "Cumulative Net Amount ($)")

agg_fund_plot
```


###visualizing the "Function" category


### visualize the "Account" category

#### visualize revenue by code
```{r}


plot_in_range <- function(temp_range){
  
  p <- osa_agg_tables %>% 
      pluck("agg_by_code") %>% 
      pluck("agg_account") %>% 
      filter(str_detect(account, paste0("^",temp_range))) %>% #only selects taxes
      ggplot(aes(x=account, y=total_amount))+ geom_bar(stat = "identity", fill = "lightcoral")+
      coord_flip()+
      geom_text(aes(label=paste0("$",total_amount)), hjust = -.25,vjust=0, size=3)+
      labs(title = paste0("Barplot of UCOA Account in Range: ", temp_range,"0000") )
  p
  
}

temp_sequence_revenues <- seq(from = 3000, to = 3009,  by=1)

revenue_plots<- temp_sequence_revenues %>% map(plot_in_range)
names(revenue_plots) <- c("revenues",
                  "taxes",
                  "licenses_and_permits",
                  "intergovernmental",
                  "charges_for_service",
                  "fines_and_forfeitures",
                  "miscellaneous",
                  "other_sources_of_funding",
                  "special_and_extraordinary_gain",
                  "suspense")

temp_sequence_expenditures <- seq(from = 4000, to = 4017,  by=1)

expenditure_plots<- temp_sequence_expenditures %>% map(plot_in_range)
names(expenditure_plots) <- c("expenditures",
                  "personnel_services",
                  "general_and_contracted_services",
                  "utilities_and_utility_services",
                  "taxes_and_fees",
                  "supplies_and_materials",
                  "grants_and_contracts",
                  "direct_payments",
                  "capital_outlays",
                  "interdepartmental_charges",
                  "judgements_and_losses",
                  "other_financing_uses",
                  "depreciation",
                  "amortiaton",
                  "bad_debt_expense",
                  "contingencies",
                  "special_and_extraordinary_loss",
                  "debt_service")

#consolidate objects
account_plots <- list(revenue_plots, expenditure_plots)
names(account_plots) <- c("revenue_plots", "expenditure_plots")

#remove redundant objects
rm(temp_sequence_revenues, temp_sequence_expenditures, revenue_plots, expenditure_plots)
```
##### view the plots
```{r}
#to see all plot simply run:
account_plots

```
To only view the revenue plots, we pluck it from the list.
```{r}
temp <- account_plots %>% pluck("revenue_plots") 
temp
```
If you are only interested in one plot, use the following code
```{r}
temp <- account_plots %>% 
  pluck("expenditure_plots") %>% 
  pluck("capital_outlays")
temp
```


To access elements of the plot, use this code format. The code below selects the data frame used to generate the plot from 
```{r}
temp_zoom <- account_plots %>% 
  pluck("revenue_plots") %>%
  pluck("intergovernmental") %>%
  pluck("data")
```


#### visualize revenue by description
 if the data is properly cleaned then this chunk is redundant. 
```{r}


plot_in_range <- function(temp_range){
  
  p <- osa_agg_tables %>% 
      pluck("agg_by_description_and_code") %>% 
      pluck("agg_account") %>% 
      filter(str_detect(account, paste0("^",temp_range))) %>% #only selects taxes
      ggplot(aes(x=account_description, y=total_amount))+ geom_bar(stat = "identity", fill = "lightcoral")+
      coord_flip()+
      geom_text(aes(label=paste0("$",total_amount)), hjust = -.25,vjust=0, size=3)+
      labs(title = paste0("Barplot of Account Revenues in Range: ", temp_range,"0000") )
  p
  
}

temp_sequence_revenues <- seq(from = 3000, to = 3009,  by=1)

revenue_plots<- temp_sequence_revenues %>% map(plot_in_range)
names(revenue_plots) <- c("revenues",
                  "taxes",
                  "licenses_and_permits",
                  "intergovernmental",
                  "charges_for_service",
                  "fines_and_forfeitures",
                  "miscellaneous",
                  "other_sources_of_funding",
                  "special_and_extraordinary_gain",
                  "suspense")

temp_sequence_expenditures <- seq(from = 4000, to = 4017,  by=1)

expenditure_plots<- temp_sequence_expenditures %>% map(plot_in_range)
names(expenditure_plots) <- c("expenditures",
                  "personnel_services",
                  "general_and_contracted_services",
                  "utilities_and_utility_services",
                  "taxes_and_fees",
                  "supplies_and_materials",
                  "grants_and_contracts",
                  "direct_payments",
                  "capital_outlays",
                  "interdepartmental_charges",
                  "judgements_and_losses",
                  "other_financing_uses",
                  "depreciation",
                  "amortiaton",
                  "bad_debt_expense",
                  "contingencies",
                  "special_and_extraordinary_loss",
                  "debt_service")

#consolidate objects
account_plots <- list(revenue_plots, expenditure_plots)
names(account_plots) <- c("revenue_plots", "expenditure_plots")

#remove redundant objects
rm(temp_sequence_revenues, temp_sequence_expenditures, revenue_plots, expenditure_plots)
```

```{r}
account_plots %>% pluck("revenue_plots")
```


You can access plot elements to quickly zoom in on the data. for example:
```{r}
#temp_zoom <- plots %>% pluck("intergovernmental") %>% pluck("data")
```

#VII. Generate Invalid Report

## na_or_empty : Examine transactions with na or empty value for their account number
```{r}
invalid_tables %>% pluck("na_or_empty")
```

## invalid_length : Examine transactions with an account number too long or too small to fit either LEA or non-LEA UCOA.
```{r}
invalid_tables %>% pluck("invalid_length")
```

## invalid_lea_format : Examine transactions for LEAs with an account number with correct length, but incorrect format
```{r}
invalid_tables %>% pluck("invalid_lea_format")
```


## invalid_osa_format : Examine transactions for non LEAs with an account number with correct length, but incorrect format
```{r}
invalid_tables %>% pluck("invalid_osa_format")
```

## unmapped_fund_code : Examine transactions for non LEAs with an account number with correct length, and correct format, but the fund code provided does not map to the ucoa code spreadsheet
```{r}
invalid_tables %>% pluck("unmapped_fund_code")
```


## unmapped_fund_code : Examine transactions for non LEAs with an account number with correct length, and correct format, but the function code provided does not map to the ucoa code spreadsheet
```{r}
invalid_tables %>% pluck("unmapped_funct_code")
```
## unmapped_account_code : Examine transactions for non LEAs with an account number with correct length, and correct format, but the account code provided does not map to the ucoa code spreadsheet
```{r}
invalid_tables %>% pluck("unmapped_account_code")
```




